import { S as SvelteComponent, i as init, s as safe_not_equal, e as element, a1 as text, b as attr, h as insert, j as append, a2 as set_data, n as noop, m as detach, a0 as onMount, X as svg_element, a as space, G as create_component, H as mount_component, l as listen, B as group_outros, D as transition_out, C as check_outros, A as transition_in, z as add_render_callback, aa as create_bidirectional_transition, ab as fade, I as destroy_component, r as run_all, M as createEventDispatcher, v as onDestroy, f as src_url_equal, L as empty, c as toggle_class, $ as bubble, y as binding_callbacks, a3 as bind, a4 as add_flush_callback, d as set_style, E as destroy_each, O as stop_propagation, ac as update_keyed_each, ad as outro_and_destroy_block, T as is_function, F as globals, ae as HtmlTag, af as set_input_value, ag as select_option, ah as select_value, o as component_subscribe, V as create_out_transition } from './node_modules/svelte@3.53.1.js';
import { t as theme } from './index.js';
import { h as hammer } from './node_modules/hammerjs@2.0.8.js';
import { W as Wo, m as ma, p as pn } from './node_modules/axentix@2.2.1.js';
import { S as Swal } from './node_modules/sweetalert2@11.6.15.js';
import './node_modules/svelte-local-storage-store@0.3.1_svelte@3.53.1.js';
import './node_modules/feathericon@1.0.2.js';
import './node_modules/popmotion@11.0.5.js';
import './node_modules/style-value-types@5.1.2.js';
import './node_modules/hey-listen@1.0.8.js';
import './node_modules/date-fns@2.29.3.js';
import './node_modules/browserfs@1.4.3.js';
import './node_modules/pify@6.1.0.js';

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/MimeTypes.svelte generated by Svelte v3.53.1 */

function isMimeTypeImage(mt) {
	return mt.startsWith("image/");
}

function isMimeTypeVideo(mt) {
	return mt.startsWith("video/");
}

function isMimeTypeAudio(mt) {
	return mt.startsWith("audio/");
}

function isMimeTypeText(mt) {
	return mt.startsWith("text/");
}

function isMimeTypePDF(mt) {
	return mt == "application/pdf";
}

function isMimeTypeSupported(mt) {
	return isMimeTypeImage(mt) || isMimeTypeVideo(mt) || isMimeTypeAudio(mt) || isMimeTypePDF(mt) || isMimeTypeText(mt);
}

function getIcon(mimeType, isLink) {
	// quick and dirty
	const icons = globalThis.icons;

	const icon = icons[mimeType == "#directory"
	? "directory"
	: isMimeTypeImage(mimeType)
		? "file-image"
		: isMimeTypeVideo(mimeType)
			? "file-video"
			: isMimeTypeAudio(mimeType)
				? "file-audio"
				: isMimeTypeText(mimeType)
					? "file-text"
					: isMimeTypePDF(mimeType) ? "file-pdf" : "file"]; // default. also symlinks

	return mimeType == "#unresolved"
	? [icon, "invalidLink", "🔗 "]
	: isLink ? [icon, "link", "🔗 "] : [icon, null, ""];
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/Struct.svelte generated by Svelte v3.53.1 */

function sortDirs(f1, f2) {
	const f1Dir = f1.mimeType === "#directory";
	const f2Dir = f2.mimeType === "#directory";
	return f1Dir == f2Dir ? 0 : f2Dir ? 1 : -1;
}

class File {
	constructor(isLink, mimeType, name, size, chDate, owner, group, permissions, path) {
		this.uuid = Math.random().toString().substring(2);
		this.mimeType = mimeType;
		this.isDir = mimeType == "#directory";
		this.isRoot = this.isDir && this.name == "..";
		this.isLink = isLink;
		this.icon = getIcon(this.mimeType, this.isLink);
		this.name = name + (this.isDir ? "/" : "");
		this.size = formatBytes(size);
		this.numSize = size;
		this.chDate = new Date(chDate * 1000).toLocaleString("af");
		this.numChDate = chDate;
		this.owner = owner;
		this.group = group;
		this.permissions = permissions;
		this.path = (path.length ? "/" + path.join("/") : "") + "/" + this.name;

		// Adapted from
		// https://stackoverflow.com/questions/15900485/correct-way-to-convert-size-in-bytes-to-kb-mb-gb-in-javascript
		function formatBytes(bytes, decimals = 2) {
			if (bytes < 0) return "";
			if (bytes === 0) return "0 b";
			const k = 1024;
			const dm = decimals < 0 ? 0 : decimals;
			const sizes = ["b", "Kb", "Mb", "Gb", "Tb", "Pb", "Eb", "Zb", "Yb"];
			const i = Math.floor(Math.log(bytes) / Math.log(k));
			return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i];
		}
	}

	getWS(forDl = false) {
		return "file?path=" + encodeURIComponent(this.path) + (forDl ? "&dl=1" : "");
	}
}

const SORTERS = {
	ABC(f1, f2) {
		const fromDir = sortDirs(f1, f2);
		return fromDir == 0 ? f1.name.localeCompare(f2.name) : fromDir;
	},
	CBA(f1, f2) {
		const fromDir = sortDirs(f1, f2);
		return fromDir == 0 ? f2.name.localeCompare(f1.name) : fromDir;
	},
	OldFirst(f1, f2) {
		const fromDir = sortDirs(f1, f2);

		return fromDir == 0
		? Math.sign(f1.numChDate - f2.numChDate)
		: fromDir;
	},
	OldLast(f1, f2) {
		const fromDir = sortDirs(f1, f2);

		return fromDir == 0
		? Math.sign(f2.numChDate - f1.numChDate)
		: fromDir;
	},
	SmallFirst(f1, f2) {
		const fromDir = sortDirs(f1, f2);

		return fromDir == 0
		? Math.sign(f1.numSize - f2.numSize)
		: fromDir;
	},
	SmallLast(f1, f2) {
		const fromDir = sortDirs(f1, f2);

		return fromDir == 0
		? Math.sign(f2.numSize - f1.numSize)
		: fromDir;
	}
};

class Mule {
	constructor(items, path) {
		this.items = [];
		this.files = []; // without dirs

		for (let i = 0; i < items.length; i++) {
			const nf = new File(items[i].isLink, items[i].mimeType, items[i].name, items[i].size, items[i].chDate, items[i].owner, items[i].group, items[i].permissions, path);
			this.items.push(nf);

			if (!nf.isDir) {
				this.files.push(nf);
			}
		}
	} /*
// add ".." parent dir
if (path.length > 0) {
    // Is not root
    this.items.unshift(
        new File(false, "#directory", "..", -1, 0, "--", "--", "--", path)
    );
}
*/

	sort(sorter) {
		this.items.sort(sorter);
		this.files.sort(sorter);
		return this;
	}

	static empty() {
		return new Mule([], []);
	}

	static fromAny(obj, path) {
		return new Mule(obj.items, path);
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/Snippets/TextShower.svelte generated by Svelte v3.53.1 */

function create_fragment$v(ctx) {
	let div;
	let pre;
	let t;
	let div_title_value;

	return {
		c() {
			div = element("div");
			pre = element("pre");
			t = text(/*contents*/ ctx[1]);
			attr(div, "title", div_title_value = /*file*/ ctx[0].name);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, pre);
			append(pre, t);
		},
		p(ctx, [dirty]) {
			if (dirty & /*contents*/ 2) set_data(t, /*contents*/ ctx[1]);

			if (dirty & /*file*/ 1 && div_title_value !== (div_title_value = /*file*/ ctx[0].name)) {
				attr(div, "title", div_title_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$v($$self, $$props, $$invalidate) {
	let contents;
	const fs = globalThis.fs;
	let { url } = $$props;
	let { file } = $$props;

	onMount(async () => {
		//contents = await (await fetch(url)).text();
		$$invalidate(1, contents = await fs.promises.readFile(file.path, 'utf8'));
	});

	$$self.$$set = $$props => {
		if ('url' in $$props) $$invalidate(2, url = $$props.url);
		if ('file' in $$props) $$invalidate(0, file = $$props.file);
	};

	$$invalidate(1, contents = "");
	return [file, contents, url];
}

class TextShower extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$v, create_fragment$v, safe_not_equal, { url: 2, file: 0 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconDownload.svelte generated by Svelte v3.53.1 */

function create_fragment$u(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$u($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconDownload extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$u, create_fragment$u, safe_not_equal, { size: 0, color: 1 });
	}
}

const Slideshow_svelte_svelte_type_style_lang = '';

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/Preview/Slideshow.svelte generated by Svelte v3.53.1 */

function create_else_block$5(ctx) {
	let img;
	let img_alt_value;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "darkmode-invert centered-slide svelte-1dkimwh");
			attr(img, "alt", img_alt_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].icon[0]);
			attr(img, "draggable", "false");
			attr(img, "ondragstart", "return false;");
			if (!src_url_equal(img.src, img_src_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].icon[0])) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*files, fileIdx*/ 3 && img_alt_value !== (img_alt_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].icon[0])) {
				attr(img, "alt", img_alt_value);
			}

			if (dirty & /*files, fileIdx*/ 3 && !src_url_equal(img.src, img_src_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].icon[0])) {
				attr(img, "src", img_src_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (169:8) {#if isMimeTypeSupported(files[fileIdx].mimeType)}
function create_if_block$7(ctx) {
	let show_if;
	let show_if_1;
	let show_if_2;
	let show_if_3;
	let show_if_4;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block_1$6,
		create_if_block_2$3,
		create_if_block_3$2,
		create_if_block_4$1,
		create_if_block_5$1
	];

	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (dirty & /*files, fileIdx*/ 3) show_if = null;
		if (dirty & /*files, fileIdx*/ 3) show_if_1 = null;
		if (dirty & /*files, fileIdx*/ 3) show_if_2 = null;
		if (dirty & /*files, fileIdx*/ 3) show_if_3 = null;
		if (dirty & /*files, fileIdx*/ 3) show_if_4 = null;
		if (show_if == null) show_if = !!isMimeTypeText(/*files*/ ctx[1][/*fileIdx*/ ctx[0]].mimeType);
		if (show_if) return 0;
		if (show_if_1 == null) show_if_1 = !!isMimeTypeImage(/*files*/ ctx[1][/*fileIdx*/ ctx[0]].mimeType);
		if (show_if_1) return 1;
		if (show_if_2 == null) show_if_2 = !!isMimeTypeVideo(/*files*/ ctx[1][/*fileIdx*/ ctx[0]].mimeType);
		if (show_if_2) return 2;
		if (show_if_3 == null) show_if_3 = !!isMimeTypeAudio(/*files*/ ctx[1][/*fileIdx*/ ctx[0]].mimeType);
		if (show_if_3) return 3;
		if (show_if_4 == null) show_if_4 = !!isMimeTypePDF(/*files*/ ctx[1][/*fileIdx*/ ctx[0]].mimeType);
		if (show_if_4) return 4;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx, -1))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

// (192:61) 
function create_if_block_5$1(ctx) {
	let embed;
	let embed_type_value;
	let embed_src_value;

	return {
		c() {
			embed = element("embed");
			attr(embed, "class", "centered-slide centered-maxscreen w100 h100 svelte-1dkimwh");
			attr(embed, "type", embed_type_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].mimeType);
			if (!src_url_equal(embed.src, embed_src_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].getWS(false))) attr(embed, "src", embed_src_value);
		},
		m(target, anchor) {
			insert(target, embed, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*files, fileIdx*/ 3 && embed_type_value !== (embed_type_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].mimeType)) {
				attr(embed, "type", embed_type_value);
			}

			if (dirty & /*files, fileIdx*/ 3 && !src_url_equal(embed.src, embed_src_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].getWS(false))) {
				attr(embed, "src", embed_src_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(embed);
		}
	};
}

// (185:63) 
function create_if_block_4$1(ctx) {
	let div;
	let audio;
	let source;
	let source_src_value;
	let source_type_value;
	let t;

	return {
		c() {
			div = element("div");
			audio = element("audio");
			source = element("source");
			t = text("\n                        Your browser does not support the audio tag.");
			if (!src_url_equal(source.src, source_src_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].getWS(false))) attr(source, "src", source_src_value);
			attr(source, "type", source_type_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].mimeType);
			attr(source, "class", "svelte-1dkimwh");
			audio.controls = true;
			attr(audio, "class", "svelte-1dkimwh");
			attr(div, "class", "centered-slide svelte-1dkimwh");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, audio);
			append(audio, source);
			append(audio, t);
		},
		p(ctx, dirty) {
			if (dirty & /*files, fileIdx*/ 3 && !src_url_equal(source.src, source_src_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].getWS(false))) {
				attr(source, "src", source_src_value);
			}

			if (dirty & /*files, fileIdx*/ 3 && source_type_value !== (source_type_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].mimeType)) {
				attr(source, "type", source_type_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (178:63) 
function create_if_block_3$2(ctx) {
	let div;
	let video;
	let source;
	let source_src_value;
	let source_type_value;
	let t;

	return {
		c() {
			div = element("div");
			video = element("video");
			source = element("source");
			t = text("\n                        Your browser does not support the video tag.");
			if (!src_url_equal(source.src, source_src_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].getWS(false))) attr(source, "src", source_src_value);
			attr(source, "type", source_type_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].mimeType);
			attr(source, "class", "svelte-1dkimwh");
			video.controls = true;
			attr(video, "class", "svelte-1dkimwh");
			attr(div, "class", "centered-slide svelte-1dkimwh");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, video);
			append(video, source);
			append(video, t);
		},
		p(ctx, dirty) {
			if (dirty & /*files, fileIdx*/ 3 && !src_url_equal(source.src, source_src_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].getWS(false))) {
				attr(source, "src", source_src_value);
			}

			if (dirty & /*files, fileIdx*/ 3 && source_type_value !== (source_type_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].mimeType)) {
				attr(source, "type", source_type_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (174:63) 
function create_if_block_2$3(ctx) {
	let img;
	let img_alt_value;
	let img_title_value;
	let img_src_value;
	let mounted;
	let dispose;

	return {
		c() {
			img = element("img");
			attr(img, "alt", img_alt_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].name);
			attr(img, "title", img_title_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].name);
			attr(img, "draggable", "false");
			attr(img, "ondragstart", "return false;");
			attr(img, "class", "centered-slide centered-maxscreen cursor-zoom-in svelte-1dkimwh");
			if (!src_url_equal(img.src, img_src_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].getWS(false))) attr(img, "src", img_src_value);
			toggle_class(img, "darkmode-invert", true);
		},
		m(target, anchor) {
			insert(target, img, anchor);

			if (!mounted) {
				dispose = listen(img, "click", /*stepMode*/ ctx[3]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*files, fileIdx*/ 3 && img_alt_value !== (img_alt_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].name)) {
				attr(img, "alt", img_alt_value);
			}

			if (dirty & /*files, fileIdx*/ 3 && img_title_value !== (img_title_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].name)) {
				attr(img, "title", img_title_value);
			}

			if (dirty & /*files, fileIdx*/ 3 && !src_url_equal(img.src, img_src_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].getWS(false))) {
				attr(img, "src", img_src_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(img);
			mounted = false;
			dispose();
		}
	};
}

// (170:12) {#if isMimeTypeText(files[fileIdx].mimeType)}
function create_if_block_1$6(ctx) {
	let div;
	let textshower;
	let current;

	textshower = new TextShower({
			props: {
				url: /*files*/ ctx[1][/*fileIdx*/ ctx[0]].getWS(false),
				file: /*files*/ ctx[1][/*fileIdx*/ ctx[0]]
			}
		});

	return {
		c() {
			div = element("div");
			create_component(textshower.$$.fragment);
			attr(div, "class", "centered-slide centered-maxscreen text-pane svelte-1dkimwh");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(textshower, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const textshower_changes = {};
			if (dirty & /*files, fileIdx*/ 3) textshower_changes.url = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].getWS(false);
			if (dirty & /*files, fileIdx*/ 3) textshower_changes.file = /*files*/ ctx[1][/*fileIdx*/ ctx[0]];
			textshower.$set(textshower_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textshower.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textshower.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(textshower);
		}
	};
}

function create_fragment$t(ctx) {
	let div7;
	let div0;
	let t0;
	let div3;
	let div1;
	let t1_value = /*fileIdx*/ ctx[0] + 1 + "";
	let t1;
	let t2;
	let t3_value = /*files*/ ctx[1].length + "";
	let t3;
	let t4;
	let show_if;
	let current_block_type_index;
	let if_block;
	let t5;
	let div2;
	let t6_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].name + "";
	let t6;
	let div2_title_value;
	let t7;
	let div4;
	let a;
	let icondownload;
	let a_href_value;
	let t8;
	let div5;
	let t10;
	let div6;
	let div7_transition;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block$7, create_else_block$5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty & /*files, fileIdx*/ 3) show_if = null;
		if (show_if == null) show_if = !!isMimeTypeSupported(/*files*/ ctx[1][/*fileIdx*/ ctx[0]].mimeType);
		if (show_if) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	icondownload = new IconDownload({ props: { size: 24, color: "white" } });

	return {
		c() {
			div7 = element("div");
			div0 = element("div");
			t0 = space();
			div3 = element("div");
			div1 = element("div");
			t1 = text(t1_value);
			t2 = text(" / ");
			t3 = text(t3_value);
			t4 = space();
			if_block.c();
			t5 = space();
			div2 = element("div");
			t6 = text(t6_value);
			t7 = space();
			div4 = element("div");
			a = element("a");
			create_component(icondownload.$$.fragment);
			t8 = space();
			div5 = element("div");
			div5.textContent = "❮";
			t10 = space();
			div6 = element("div");
			div6.textContent = "❯";
			attr(div0, "class", "x-top-right cursor-pointer svelte-1dkimwh");
			attr(div1, "class", "numbertext svelte-1dkimwh");
			attr(div2, "class", "caption ellipsis svelte-1dkimwh");
			attr(div2, "title", div2_title_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].name);
			attr(div3, "class", "slideshow-container svelte-1dkimwh");
			attr(a, "target", "_blank");
			attr(a, "href", a_href_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].getWS(true));
			attr(a, "class", "svelte-1dkimwh");
			attr(div4, "class", "download svelte-1dkimwh");
			attr(div4, "title", "Download");
			attr(div5, "class", "prev svelte-1dkimwh");
			attr(div6, "class", "next svelte-1dkimwh");
			attr(div7, "id", "slide-container");
			attr(div7, "class", "blanket svelte-1dkimwh");
		},
		m(target, anchor) {
			insert(target, div7, anchor);
			append(div7, div0);
			append(div7, t0);
			append(div7, div3);
			append(div3, div1);
			append(div1, t1);
			append(div1, t2);
			append(div1, t3);
			append(div3, t4);
			if_blocks[current_block_type_index].m(div3, null);
			append(div3, t5);
			append(div3, div2);
			append(div2, t6);
			append(div7, t7);
			append(div7, div4);
			append(div4, a);
			mount_component(icondownload, a, null);
			append(div7, t8);
			append(div7, div5);
			append(div7, t10);
			append(div7, div6);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "click", /*close*/ ctx[2]),
					listen(div5, "click", /*prev*/ ctx[5]),
					listen(div6, "click", /*next*/ ctx[4])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*fileIdx*/ 1) && t1_value !== (t1_value = /*fileIdx*/ ctx[0] + 1 + "")) set_data(t1, t1_value);
			if ((!current || dirty & /*files*/ 2) && t3_value !== (t3_value = /*files*/ ctx[1].length + "")) set_data(t3, t3_value);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div3, t5);
			}

			if ((!current || dirty & /*files, fileIdx*/ 3) && t6_value !== (t6_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].name + "")) set_data(t6, t6_value);

			if (!current || dirty & /*files, fileIdx*/ 3 && div2_title_value !== (div2_title_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].name)) {
				attr(div2, "title", div2_title_value);
			}

			if (!current || dirty & /*files, fileIdx*/ 3 && a_href_value !== (a_href_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].getWS(true))) {
				attr(a, "href", a_href_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(icondownload.$$.fragment, local);

			add_render_callback(() => {
				if (!div7_transition) div7_transition = create_bidirectional_transition(div7, fade, {}, true);
				div7_transition.run(1);
			});

			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(icondownload.$$.fragment, local);
			if (!div7_transition) div7_transition = create_bidirectional_transition(div7, fade, {}, false);
			div7_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div7);
			if_blocks[current_block_type_index].d();
			destroy_component(icondownload);
			if (detaching && div7_transition) div7_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$t($$self, $$props, $$invalidate) {
	let { files } = $$props;
	let { fileIdx } = $$props;
	const dispatch = createEventDispatcher();
	let manager;

	onMount(() => {
		document.addEventListener('keydown', handleKeyboardEvent);
		manager = new hammer.exports.Manager(document.getElementById("slide-container"));
		manager.add(new hammer.exports.Swipe());
		manager.on('swipeleft', next);
		manager.on('swiperight', prev);
	});

	onDestroy(() => {
		document.removeEventListener('keydown', handleKeyboardEvent);
		manager.destroy();
	});

	// adapted from https://siongui.github.io/2012/06/25/javascript-keyboard-event-arrow-key-example/
	function handleKeyboardEvent(evt) {
		const keycode = evt.keyCode || evt.which;

		switch (keycode) {
			case 37:
				// Left
				prev();
				break;
			case 39:
				// Right
				next();
				break;
		}
	}

	function close(e) {
		dispatch("closePreview", {});
	}

	function stepMode() {
		dispatch("stepMode", {});
	}

	function next() {
		if ($$invalidate(0, ++fileIdx) == files.length) $$invalidate(0, fileIdx = 0);
	}

	function prev() {
		if ($$invalidate(0, fileIdx--, fileIdx) == 0) $$invalidate(0, fileIdx = files.length - 1);
	}

	$$self.$$set = $$props => {
		if ('files' in $$props) $$invalidate(1, files = $$props.files);
		if ('fileIdx' in $$props) $$invalidate(0, fileIdx = $$props.fileIdx);
	};

	return [fileIdx, files, close, stepMode, next, prev];
}

class Slideshow extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$t, create_fragment$t, safe_not_equal, { files: 1, fileIdx: 0 });
	}
}

const FullScreen_svelte_svelte_type_style_lang = '';

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/Preview/FullScreen.svelte generated by Svelte v3.53.1 */

function create_fragment$s(ctx) {
	let div;
	let img;
	let img_alt_value;
	let img_title_value;
	let img_src_value;
	let div_transition;
	let current;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			img = element("img");
			attr(img, "alt", img_alt_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].name);
			attr(img, "title", img_title_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].name);
			attr(img, "draggable", "false");
			attr(img, "ondragstart", "return false;");
			attr(img, "class", "centered-slide cursor-zoom-in shadow-5 full-screen svelte-2bjq9d");
			if (!src_url_equal(img.src, img_src_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].getWS(false))) attr(img, "src", img_src_value);
			attr(div, "id", "img-container");
			attr(div, "class", "blanket blanket-clear");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, img);
			current = true;

			if (!mounted) {
				dispose = listen(img, "click", /*stepMode*/ ctx[2]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*files, fileIdx*/ 3 && img_alt_value !== (img_alt_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].name)) {
				attr(img, "alt", img_alt_value);
			}

			if (!current || dirty & /*files, fileIdx*/ 3 && img_title_value !== (img_title_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].name)) {
				attr(img, "title", img_title_value);
			}

			if (!current || dirty & /*files, fileIdx*/ 3 && !src_url_equal(img.src, img_src_value = /*files*/ ctx[1][/*fileIdx*/ ctx[0]].getWS(false))) {
				attr(img, "src", img_src_value);
			}
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
				div_transition.run(1);
			});

			current = true;
		},
		o(local) {
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
			div_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (detaching && div_transition) div_transition.end();
			mounted = false;
			dispose();
		}
	};
}

function instance$s($$self, $$props, $$invalidate) {
	let { files } = $$props;
	let { fileIdx } = $$props;
	const dispatch = createEventDispatcher();
	let manager;

	onMount(() => {
		document.addEventListener('keydown', handleKeyboardEvent);
		manager = new hammer.exports.Manager(document.getElementById("img-container"));
		manager.add(new hammer.exports.Swipe());
		manager.on('swipeleft', next);
		manager.on('swiperight', prev);
	});

	onDestroy(() => {
		document.removeEventListener('keydown', handleKeyboardEvent);
		manager.destroy();
	});

	// adapted from https://siongui.github.io/2012/06/25/javascript-keyboard-event-arrow-key-example/
	function handleKeyboardEvent(evt) {
		const keycode = evt.keyCode || evt.which;

		switch (keycode) {
			case 37:
				// Left
				prev();
				break;
			case 39:
				// Right
				next();
				break;
		}
	}

	function stepMode() {
		dispatch("stepMode", {});
	}

	function next() {
		const next = files.findIndex((f, i) => {
			return i > fileIdx && isMimeTypeImage(f.mimeType);
		});

		if (next < 0) $$invalidate(0, fileIdx = files.findIndex(f => {
			return isMimeTypeImage(f.mimeType);
		})); else $$invalidate(0, fileIdx = next);
	}

	function prev() {
		function findLastIndex(array, predicate) {
			let l = array.length;

			while (l--) {
				if (predicate(array[l], l, array)) return l;
			}

			return -1;
		}

		const prev = findLastIndex(files, (f, i) => {
			return i < fileIdx && isMimeTypeImage(f.mimeType);
		});

		if (prev < 0) $$invalidate(0, fileIdx = findLastIndex(files, f => {
			return isMimeTypeImage(f.mimeType);
		})); else $$invalidate(0, fileIdx = prev);
	}

	$$self.$$set = $$props => {
		if ('files' in $$props) $$invalidate(1, files = $$props.files);
		if ('fileIdx' in $$props) $$invalidate(0, fileIdx = $$props.fileIdx);
	};

	return [fileIdx, files, stepMode];
}

class FullScreen extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$s, create_fragment$s, safe_not_equal, { files: 1, fileIdx: 0 });
	}
}

const FullSize_svelte_svelte_type_style_lang = '';

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/Preview/FullSize.svelte generated by Svelte v3.53.1 */

function create_fragment$r(ctx) {
	let div;
	let div_transition;
	let t;
	let img_1;
	let img_1_alt_value;
	let img_1_title_value;
	let img_1_src_value;
	let current;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			t = space();
			img_1 = element("img");
			attr(div, "class", "blanket blanket-very-clear");
			attr(img_1, "id", "image");
			attr(img_1, "alt", img_1_alt_value = /*file*/ ctx[0].name);
			attr(img_1, "title", img_1_title_value = /*file*/ ctx[0].name);
			attr(img_1, "class", "top-left cursor-zoom-out shadow-5 svelte-ulvr4n");
			attr(img_1, "draggable", "false");
			attr(img_1, "ondragstart", "return false;");
			if (!src_url_equal(img_1.src, img_1_src_value = /*file*/ ctx[0].getWS(false))) attr(img_1, "src", img_1_src_value);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			insert(target, t, anchor);
			insert(target, img_1, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(img_1, "click", /*stepMode*/ ctx[1]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*file*/ 1 && img_1_alt_value !== (img_1_alt_value = /*file*/ ctx[0].name)) {
				attr(img_1, "alt", img_1_alt_value);
			}

			if (!current || dirty & /*file*/ 1 && img_1_title_value !== (img_1_title_value = /*file*/ ctx[0].name)) {
				attr(img_1, "title", img_1_title_value);
			}

			if (!current || dirty & /*file*/ 1 && !src_url_equal(img_1.src, img_1_src_value = /*file*/ ctx[0].getWS(false))) {
				attr(img_1, "src", img_1_src_value);
			}
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
				div_transition.run(1);
			});

			current = true;
		},
		o(local) {
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
			div_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (detaching && div_transition) div_transition.end();
			if (detaching) detach(t);
			if (detaching) detach(img_1);
			mounted = false;
			dispose();
		}
	};
}

function instance$r($$self, $$props, $$invalidate) {
	let { file } = $$props;
	const dispatch = createEventDispatcher();

	async function stepMode() {
		dispatch("stepMode", {});
	}

	onMount(() => {
		const img = document.getElementById("image");
		const ww = window.innerWidth;
		const wh = window.innerHeight;
		const iw = img.clientWidth;
		const ih = img.clientHeight;
		if (ww > iw) img.style.left = (ww - iw) / 2 + "px";
		if (wh > ih) img.style.top = (wh - ih) / 2 + "px";
	});

	$$self.$$set = $$props => {
		if ('file' in $$props) $$invalidate(0, file = $$props.file);
	};

	return [file, stepMode];
}

class FullSize extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$r, create_fragment$r, safe_not_equal, { file: 0 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/Preview/Preview.svelte generated by Svelte v3.53.1 */

function create_else_block$4(ctx) {
	let fullsize;
	let current;

	fullsize = new FullSize({
			props: {
				file: /*files*/ ctx[1][/*fileIdx*/ ctx[0]]
			}
		});

	fullsize.$on("stepMode", /*doStepMode*/ ctx[3]);

	return {
		c() {
			create_component(fullsize.$$.fragment);
		},
		m(target, anchor) {
			mount_component(fullsize, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const fullsize_changes = {};
			if (dirty & /*files, fileIdx*/ 3) fullsize_changes.file = /*files*/ ctx[1][/*fileIdx*/ ctx[0]];
			fullsize.$set(fullsize_changes);
		},
		i(local) {
			if (current) return;
			transition_in(fullsize.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(fullsize.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(fullsize, detaching);
		}
	};
}

// (38:20) 
function create_if_block_1$5(ctx) {
	let fullscreen;
	let updating_fileIdx;
	let current;

	function fullscreen_fileIdx_binding(value) {
		/*fullscreen_fileIdx_binding*/ ctx[6](value);
	}

	let fullscreen_props = { files: /*files*/ ctx[1] };

	if (/*fileIdx*/ ctx[0] !== void 0) {
		fullscreen_props.fileIdx = /*fileIdx*/ ctx[0];
	}

	fullscreen = new FullScreen({ props: fullscreen_props });
	binding_callbacks.push(() => bind(fullscreen, 'fileIdx', fullscreen_fileIdx_binding));
	fullscreen.$on("stepMode", /*doStepMode*/ ctx[3]);

	return {
		c() {
			create_component(fullscreen.$$.fragment);
		},
		m(target, anchor) {
			mount_component(fullscreen, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const fullscreen_changes = {};
			if (dirty & /*files*/ 2) fullscreen_changes.files = /*files*/ ctx[1];

			if (!updating_fileIdx && dirty & /*fileIdx*/ 1) {
				updating_fileIdx = true;
				fullscreen_changes.fileIdx = /*fileIdx*/ ctx[0];
				add_flush_callback(() => updating_fileIdx = false);
			}

			fullscreen.$set(fullscreen_changes);
		},
		i(local) {
			if (current) return;
			transition_in(fullscreen.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(fullscreen.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(fullscreen, detaching);
		}
	};
}

// (36:0) {#if mode == 0}
function create_if_block$6(ctx) {
	let slideshow;
	let updating_fileIdx;
	let current;

	function slideshow_fileIdx_binding(value) {
		/*slideshow_fileIdx_binding*/ ctx[4](value);
	}

	let slideshow_props = { files: /*files*/ ctx[1] };

	if (/*fileIdx*/ ctx[0] !== void 0) {
		slideshow_props.fileIdx = /*fileIdx*/ ctx[0];
	}

	slideshow = new Slideshow({ props: slideshow_props });
	binding_callbacks.push(() => bind(slideshow, 'fileIdx', slideshow_fileIdx_binding));
	slideshow.$on("stepMode", /*doStepMode*/ ctx[3]);
	slideshow.$on("closePreview", /*closePreview_handler*/ ctx[5]);

	return {
		c() {
			create_component(slideshow.$$.fragment);
		},
		m(target, anchor) {
			mount_component(slideshow, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const slideshow_changes = {};
			if (dirty & /*files*/ 2) slideshow_changes.files = /*files*/ ctx[1];

			if (!updating_fileIdx && dirty & /*fileIdx*/ 1) {
				updating_fileIdx = true;
				slideshow_changes.fileIdx = /*fileIdx*/ ctx[0];
				add_flush_callback(() => updating_fileIdx = false);
			}

			slideshow.$set(slideshow_changes);
		},
		i(local) {
			if (current) return;
			transition_in(slideshow.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(slideshow.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(slideshow, detaching);
		}
	};
}

function create_fragment$q(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$6, create_if_block_1$5, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*mode*/ ctx[2] == 0) return 0;
		if (/*mode*/ ctx[2] == 1) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$q($$self, $$props, $$invalidate) {
	let mode;
	let { files } = $$props;
	let { fileIdx } = $$props;
	let lastChange = 0;

	function doStepMode() {
		if (Date.now() - lastChange > 200) $$invalidate(2, mode = (mode + 1) % 3);
	}

	function slideshow_fileIdx_binding(value) {
		fileIdx = value;
		$$invalidate(0, fileIdx);
	}

	function closePreview_handler(event) {
		bubble.call(this, $$self, event);
	}

	function fullscreen_fileIdx_binding(value) {
		fileIdx = value;
		$$invalidate(0, fileIdx);
	}

	$$self.$$set = $$props => {
		if ('files' in $$props) $$invalidate(1, files = $$props.files);
		if ('fileIdx' in $$props) $$invalidate(0, fileIdx = $$props.fileIdx);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*fileIdx, mode*/ 5) {
			{
				lastChange = Date.now();
			}
		}
	};

	$$invalidate(2, mode = 0); // 0=slideshow; 1=fullscreen; 2=full size

	return [
		fileIdx,
		files,
		mode,
		doStepMode,
		slideshow_fileIdx_binding,
		closePreview_handler,
		fullscreen_fileIdx_binding
	];
}

class Preview extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$q, create_fragment$q, safe_not_equal, { files: 1, fileIdx: 0 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/Snippets/Breadcrumb.svelte generated by Svelte v3.53.1 */

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	child_ctx[5] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	child_ctx[5] = i;
	return child_ctx;
}

// (38:4) {#if path.length > 0}
function create_if_block_3$1(ctx) {
	let a;
	let mounted;
	let dispose;

	return {
		c() {
			a = element("a");
			a.innerHTML = `<u><i>root</i></u>`;
			attr(a, "class", "font-w300 cursor-pointer");
		},
		m(target, anchor) {
			insert(target, a, anchor);

			if (!mounted) {
				dispose = listen(a, "click", /*goto*/ ctx[1](-1));
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(a);
			mounted = false;
			dispose();
		}
	};
}

// (45:8) {:else}
function create_else_block_2(ctx) {
	let span;
	let t_value = /*pItem*/ ctx[3].replace('/', '') + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
			attr(span, "class", "font-w600");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*path*/ 1 && t_value !== (t_value = /*pItem*/ ctx[3].replace('/', '') + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (42:8) {#if idx < path.length - 1}
function create_if_block_2$2(ctx) {
	let a;
	let u;
	let t_value = /*pItem*/ ctx[3].replace('/', '') + "";
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			a = element("a");
			u = element("u");
			t = text(t_value);
			attr(a, "class", "font-w300 cursor-pointer");
		},
		m(target, anchor) {
			insert(target, a, anchor);
			append(a, u);
			append(u, t);

			if (!mounted) {
				dispose = listen(a, "click", /*goto*/ ctx[1](/*idx*/ ctx[5]));
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*path*/ 1 && t_value !== (t_value = /*pItem*/ ctx[3].replace('/', '') + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(a);
			mounted = false;
			dispose();
		}
	};
}

// (41:4) {#each path as pItem, idx}
function create_each_block_1(ctx) {
	let t;

	function select_block_type(ctx, dirty) {
		if (/*idx*/ ctx[5] < /*path*/ ctx[0].length - 1) return create_if_block_2$2;
		return create_else_block_2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			t = text(" / ");
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(t.parentNode, t);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(t);
		}
	};
}

// (59:8) {:else}
function create_else_block_1$2(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<i>root</i>`;
			attr(div, "class", "dropdown-item");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (55:8) {#if path.length > 0}
function create_if_block_1$4(ctx) {
	let div;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<i>root</i>`;
			attr(div, "class", "dropdown-item pup-a-nobold cursor-pointer");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (!mounted) {
				dispose = listen(div, "click", /*goto*/ ctx[1](-1));
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (70:12) {:else}
function create_else_block$3(ctx) {
	let div;
	let t0;
	let t1_value = /*pItem*/ ctx[3].replace("/", "") + "";
	let t1;
	let t2;

	return {
		c() {
			div = element("div");
			t0 = text(" / ");
			t1 = text(t1_value);
			t2 = space();
			attr(div, "class", "dropdown-item");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
			append(div, t2);
		},
		p(ctx, dirty) {
			if (dirty & /*path*/ 1 && t1_value !== (t1_value = /*pItem*/ ctx[3].replace("/", "") + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (65:12) {#if idx < path.length - 1}
function create_if_block$5(ctx) {
	let div;
	let t0;
	let span;
	let t1_value = /*pItem*/ ctx[3].replace("/", "") + "";
	let t1;
	let t2;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			t0 = text(" / ");
			span = element("span");
			t1 = text(t1_value);
			t2 = space();
			attr(span, "class", "pup-a-nobold cursor-pointer");
			attr(div, "class", "dropdown-item");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, span);
			append(span, t1);
			append(div, t2);

			if (!mounted) {
				dispose = listen(span, "click", /*goto*/ ctx[1](/*idx*/ ctx[5]));
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*path*/ 1 && t1_value !== (t1_value = /*pItem*/ ctx[3].replace("/", "") + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (64:8) {#each path as pItem, idx}
function create_each_block$3(ctx) {
	let if_block_anchor;

	function select_block_type_2(ctx, dirty) {
		if (/*idx*/ ctx[5] < /*path*/ ctx[0].length - 1) return create_if_block$5;
		return create_else_block$3;
	}

	let current_block_type = select_block_type_2(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$p(ctx) {
	let div0;
	let t0;
	let t1;
	let div3;
	let div1;
	let t3;
	let div2;
	let t4;
	let if_block0 = /*path*/ ctx[0].length > 0 && create_if_block_3$1(ctx);
	let each_value_1 = /*path*/ ctx[0];
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	function select_block_type_1(ctx, dirty) {
		if (/*path*/ ctx[0].length > 0) return create_if_block_1$4;
		return create_else_block_1$2;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block1 = current_block_type(ctx);
	let each_value = /*path*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	return {
		c() {
			div0 = element("div");
			if (if_block0) if_block0.c();
			t0 = text(" / \n    ");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t1 = space();
			div3 = element("div");
			div1 = element("div");
			div1.innerHTML = `📍 <span class="triangle"></span>`;
			t3 = space();
			div2 = element("div");
			if_block1.c();
			t4 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", "hide-xs");
			attr(div1, "class", "navbar-link");
			attr(div1, "data-target", "Breadcrumb");
			attr(div1, "title", "Folder stack");
			set_style(div1, "height", "40px");
			attr(div2, "class", "dropdown-content white shadow-1 rounded-1");
			attr(div3, "class", "dropdown hide-sm-up");
			attr(div3, "id", "Breadcrumb");
			set_style(div3, "top", "-8px");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			if (if_block0) if_block0.m(div0, null);
			append(div0, t0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			insert(target, t1, anchor);
			insert(target, div3, anchor);
			append(div3, div1);
			append(div3, t3);
			append(div3, div2);
			if_block1.m(div2, null);
			append(div2, t4);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}
		},
		p(ctx, [dirty]) {
			if (/*path*/ ctx[0].length > 0) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3$1(ctx);
					if_block0.c();
					if_block0.m(div0, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*goto, path*/ 3) {
				each_value_1 = /*path*/ ctx[0];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div0, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(div2, t4);
				}
			}

			if (dirty & /*goto, path*/ 3) {
				each_value = /*path*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div2, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div0);
			if (if_block0) if_block0.d();
			destroy_each(each_blocks_1, detaching);
			if (detaching) detach(t1);
			if (detaching) detach(div3);
			if_block1.d();
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$p($$self, $$props, $$invalidate) {
	let { path = [] } = $$props;
	const dispatch = createEventDispatcher();

	onMount(() => {
		new Wo("#Breadcrumb");
	});

	onDestroy(() => {
		ma("#Breadcrumb");
	});

	function goto(idx) {
		return () => {
			dispatch("pathEvent", { path: path.slice(0, idx + 1) });
		};
	}

	$$self.$$set = $$props => {
		if ('path' in $$props) $$invalidate(0, path = $$props.path);
	};

	return [path, goto];
}

class Breadcrumb extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$p, create_fragment$p, safe_not_equal, { path: 0 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconLink.svelte generated by Svelte v3.53.1 */

function create_fragment$o(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M10.59,13.41C11,13.8 11,14.44 10.59,14.83C10.2,15.22 9.56,15.22 9.17,14.83C7.22,12.88 7.22,9.71 9.17,7.76V7.76L12.71,4.22C14.66,2.27 17.83,2.27 19.78,4.22C21.73,6.17 21.73,9.34 19.78,11.29L18.29,12.78C18.3,11.96 18.17,11.14 17.89,10.36L18.36,9.88C19.54,8.71 19.54,6.81 18.36,5.64C17.19,4.46 15.29,4.46 14.12,5.64L10.59,9.17C9.41,10.34 9.41,12.24 10.59,13.41M13.41,9.17C13.8,8.78 14.44,8.78 14.83,9.17C16.78,11.12 16.78,14.29 14.83,16.24V16.24L11.29,19.78C9.34,21.73 6.17,21.73 4.22,19.78C2.27,17.83 2.27,14.66 4.22,12.71L5.71,11.22C5.7,12.04 5.83,12.86 6.11,13.65L5.64,14.12C4.46,15.29 4.46,17.19 5.64,18.36C6.81,19.54 8.71,19.54 9.88,18.36L13.41,14.83C14.59,13.66 14.59,11.76 13.41,10.59C13,10.2 13,9.56 13.41,9.17Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$o($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconLink extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$o, create_fragment$o, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconInvalidLink.svelte generated by Svelte v3.53.1 */

function create_fragment$n(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M2,5.27L3.28,4L20,20.72L18.73,22L13.9,17.17L11.29,19.78C9.34,21.73 6.17,21.73 4.22,19.78C2.27,17.83 2.27,14.66 4.22,12.71L5.71,11.22C5.7,12.04 5.83,12.86 6.11,13.65L5.64,14.12C4.46,15.29 4.46,17.19 5.64,18.36C6.81,19.54 8.71,19.54 9.88,18.36L12.5,15.76L10.88,14.15C10.87,14.39 10.77,14.64 10.59,14.83C10.2,15.22 9.56,15.22 9.17,14.83C8.12,13.77 7.63,12.37 7.72,11L2,5.27M12.71,4.22C14.66,2.27 17.83,2.27 19.78,4.22C21.73,6.17 21.73,9.34 19.78,11.29L18.29,12.78C18.3,11.96 18.17,11.14 17.89,10.36L18.36,9.88C19.54,8.71 19.54,6.81 18.36,5.64C17.19,4.46 15.29,4.46 14.12,5.64L10.79,8.97L9.38,7.55L12.71,4.22M13.41,9.17C13.8,8.78 14.44,8.78 14.83,9.17C16.2,10.54 16.61,12.5 16.06,14.23L14.28,12.46C14.23,11.78 13.94,11.11 13.41,10.59C13,10.2 13,9.56 13.41,9.17Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$n($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconInvalidLink extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$n, create_fragment$n, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/FileManager/GridCell.svelte generated by Svelte v3.53.1 */

function create_else_block_1$1(ctx) {
	let img;
	let img_alt_value;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "darkmode-invert");
			attr(img, "alt", img_alt_value = /*item*/ ctx[0].icon[0]);
			if (!src_url_equal(img.src, img_src_value = /*item*/ ctx[0].icon[0])) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*item*/ 1 && img_alt_value !== (img_alt_value = /*item*/ ctx[0].icon[0])) {
				attr(img, "alt", img_alt_value);
			}

			if (dirty & /*item*/ 1 && !src_url_equal(img.src, img_src_value = /*item*/ ctx[0].icon[0])) {
				attr(img, "src", img_src_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (36:12) {#if !!item.icon[1]}
function create_if_block$4(ctx) {
	let img;
	let img_alt_value;
	let img_src_value;
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$3, create_else_block$2];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*item*/ ctx[0].icon[1] == "link") return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			img = element("img");
			t = space();
			if_block.c();
			if_block_anchor = empty();
			attr(img, "class", "darkmode-invert");
			attr(img, "alt", img_alt_value = /*item*/ ctx[0].icon[0]);
			if (!src_url_equal(img.src, img_src_value = /*item*/ ctx[0].icon[0])) attr(img, "src", img_src_value);
			set_style(img, "position", "relative");
			set_style(img, "left", "12px");
		},
		m(target, anchor) {
			insert(target, img, anchor);
			insert(target, t, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*item*/ 1 && img_alt_value !== (img_alt_value = /*item*/ ctx[0].icon[0])) {
				attr(img, "alt", img_alt_value);
			}

			if (!current || dirty & /*item*/ 1 && !src_url_equal(img.src, img_src_value = /*item*/ ctx[0].icon[0])) {
				attr(img, "src", img_src_value);
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(img);
			if (detaching) detach(t);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (40:16) {:else}
function create_else_block$2(ctx) {
	let iconinvalidlink;
	let current;
	iconinvalidlink = new IconInvalidLink({ props: { size: "22" } });

	return {
		c() {
			create_component(iconinvalidlink.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconinvalidlink, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconinvalidlink.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconinvalidlink.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconinvalidlink, detaching);
		}
	};
}

// (38:16) {#if item.icon[1] == "link"}
function create_if_block_1$3(ctx) {
	let iconlink;
	let current;
	iconlink = new IconLink({ props: { size: "22" } });

	return {
		c() {
			create_component(iconlink.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconlink, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconlink.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconlink.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconlink, detaching);
		}
	};
}

function create_fragment$m(ctx) {
	let div6;
	let div5;
	let span0;
	let t0_value = /*item*/ ctx[0].size + "";
	let t0;
	let t1;
	let div0;
	let span1;
	let t3;
	let div1;
	let t5;
	let div2;
	let current_block_type_index;
	let if_block;
	let t6;
	let div3;
	let t8;
	let div4;
	let t9_value = /*item*/ ctx[0].name + "";
	let t9;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block$4, create_else_block_1$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (!!/*item*/ ctx[0].icon[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div6 = element("div");
			div5 = element("div");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = space();
			div0 = element("div");
			span1 = element("span");
			span1.textContent = "️";
			t3 = space();
			div1 = element("div");
			div1.textContent = " ";
			t5 = space();
			div2 = element("div");
			if_block.c();
			t6 = space();
			div3 = element("div");
			div3.textContent = " ";
			t8 = space();
			div4 = element("div");
			t9 = text(t9_value);
			attr(span0, "class", "font-w100 hide-sm-down");
			attr(span1, "class", "cursor-pointer menu mr-1");
			set_style(div0, "float", "right");
			set_style(div1, "clear", "both");
			attr(div2, "class", "text-center");
			attr(div4, "class", "text-center ellipsis pb-3");
			attr(div5, "class", "card-content lh-1");
			attr(div6, "class", "card shadow-1 hoverable-1 rounded-3 overflow-visible white");
		},
		m(target, anchor) {
			insert(target, div6, anchor);
			append(div6, div5);
			append(div5, span0);
			append(span0, t0);
			append(div5, t1);
			append(div5, div0);
			append(div0, span1);
			append(div5, t3);
			append(div5, div1);
			append(div5, t5);
			append(div5, div2);
			if_blocks[current_block_type_index].m(div2, null);
			append(div5, t6);
			append(div5, div3);
			append(div5, t8);
			append(div5, div4);
			append(div4, t9);
			current = true;

			if (!mounted) {
				dispose = listen(span1, "click", stop_propagation(/*toProperties*/ ctx[1]));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*item*/ 1) && t0_value !== (t0_value = /*item*/ ctx[0].size + "")) set_data(t0, t0_value);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div2, null);
			}

			if ((!current || dirty & /*item*/ 1) && t9_value !== (t9_value = /*item*/ ctx[0].name + "")) set_data(t9, t9_value);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div6);
			if_blocks[current_block_type_index].d();
			mounted = false;
			dispose();
		}
	};
}

function instance$m($$self, $$props, $$invalidate) {
	let { item } = $$props;
	const dispatch = createEventDispatcher();

	function toProperties() {
		dispatch("openPropsModal", { file: item });
	}

	$$self.$$set = $$props => {
		if ('item' in $$props) $$invalidate(0, item = $$props.item);
	};

	return [item, toProperties];
}

class GridCell extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$m, create_fragment$m, safe_not_equal, { item: 0 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/FileManager/Grid.svelte generated by Svelte v3.53.1 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	child_ctx[7] = i;
	return child_ctx;
}

// (29:4) {#each itemList as item, i (item.uuid)}
function create_each_block$2(key_1, ctx) {
	let div;
	let gridcell;
	let t;
	let div_title_value;
	let current;
	let mounted;
	let dispose;
	gridcell = new GridCell({ props: { item: /*item*/ ctx[5] } });
	gridcell.$on("reload", /*reload_handler*/ ctx[2]);
	gridcell.$on("openPropsModal", /*openPropsModal_handler*/ ctx[3]);

	return {
		key: key_1,
		first: null,
		c() {
			div = element("div");
			create_component(gridcell.$$.fragment);
			t = space();
			attr(div, "class", "m-3 cursor-pointer");
			attr(div, "title", div_title_value = /*item*/ ctx[5].name);
			set_style(div, "z-index", /*itemList*/ ctx[0].length + 1 - /*i*/ ctx[7]);
			this.first = div;
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(gridcell, div, null);
			append(div, t);
			current = true;

			if (!mounted) {
				dispose = listen(div, "click", function () {
					if (is_function(/*click*/ ctx[1](/*item*/ ctx[5].uuid))) /*click*/ ctx[1](/*item*/ ctx[5].uuid).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const gridcell_changes = {};
			if (dirty & /*itemList*/ 1) gridcell_changes.item = /*item*/ ctx[5];
			gridcell.$set(gridcell_changes);

			if (!current || dirty & /*itemList*/ 1 && div_title_value !== (div_title_value = /*item*/ ctx[5].name)) {
				attr(div, "title", div_title_value);
			}

			if (!current || dirty & /*itemList*/ 1) {
				set_style(div, "z-index", /*itemList*/ ctx[0].length + 1 - /*i*/ ctx[7]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(gridcell.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(gridcell.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(gridcell);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$l(ctx) {
	let div;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let each_value = /*itemList*/ ctx[0];
	const get_key = ctx => /*item*/ ctx[5].uuid;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$2(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "grix xs2 sm3 md4 lg6 xl8");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*itemList, click*/ 3) {
				each_value = /*itemList*/ ctx[0];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$2, null, get_each_context$2);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

function instance$l($$self, $$props, $$invalidate) {
	let { itemList } = $$props;
	const dispatch = createEventDispatcher();

	function click(uuid) {
		return e => {
			dispatch("openItem", { uuid });
		};
	}

	function reload_handler(event) {
		bubble.call(this, $$self, event);
	}

	function openPropsModal_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('itemList' in $$props) $$invalidate(0, itemList = $$props.itemList);
	};

	return [itemList, click, reload_handler, openPropsModal_handler];
}

class Grid extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$l, create_fragment$l, safe_not_equal, { itemList: 0 });
	}
}

const ListRow_svelte_svelte_type_style_lang = '';

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/FileManager/ListRow.svelte generated by Svelte v3.53.1 */

function create_fragment$k(ctx) {
	let tr;
	let td0;
	let div0;
	let img0;
	let img0_alt_value;
	let img0_src_value;
	let t0;
	let span0;
	let t1_value = /*item*/ ctx[0].icon[2] + "";
	let t1;
	let t2_value = /*item*/ ctx[0].name + "";
	let t2;
	let t3;
	let div1;
	let img1;
	let img1_alt_value;
	let img1_src_value;
	let t4;
	let span1;
	let t5_value = /*item*/ ctx[0].icon[2] + "";
	let t5;
	let t6_value = /*item*/ ctx[0].name + "";
	let t6;
	let t7;
	let td1;
	let t8_value = /*item*/ ctx[0].size + "";
	let t8;
	let t9;
	let td2;
	let t10_value = /*item*/ ctx[0].chDate + "";
	let t10;
	let t11;
	let td3;
	let div2;
	let span2;
	let mounted;
	let dispose;

	return {
		c() {
			tr = element("tr");
			td0 = element("td");
			div0 = element("div");
			img0 = element("img");
			t0 = text(" ");
			span0 = element("span");
			t1 = text(t1_value);
			t2 = text(t2_value);
			t3 = space();
			div1 = element("div");
			img1 = element("img");
			t4 = text(" ");
			span1 = element("span");
			t5 = text(t5_value);
			t6 = text(t6_value);
			t7 = space();
			td1 = element("td");
			t8 = text(t8_value);
			t9 = space();
			td2 = element("td");
			t10 = text(t10_value);
			t11 = space();
			td3 = element("td");
			div2 = element("div");
			span2 = element("span");
			span2.textContent = "️";
			attr(img0, "class", "darkmode-invert txt-mid svelte-pq8k21");
			attr(img0, "alt", img0_alt_value = /*item*/ ctx[0].icon[0]);
			if (!src_url_equal(img0.src, img0_src_value = /*item*/ ctx[0].icon[0])) attr(img0, "src", img0_src_value);
			attr(span0, "class", "txt-mid svelte-pq8k21");
			attr(div0, "class", "wid220 ellipsis hide-md-up");
			attr(img1, "class", "darkmode-invert txt-mid svelte-pq8k21");
			attr(img1, "alt", img1_alt_value = /*item*/ ctx[0].icon[0]);
			if (!src_url_equal(img1.src, img1_src_value = /*item*/ ctx[0].icon[0])) attr(img1, "src", img1_src_value);
			attr(span1, "class", "txt-mid svelte-pq8k21");
			attr(div1, "class", "hide-sm-down");
			attr(td0, "class", "cursor-pointer nowrap minWid50Percent svelte-pq8k21");
			attr(td1, "class", "cursor-pointer nowrap minWid20Percent svelte-pq8k21");
			attr(td2, "class", "hide-sm-down cursor-pointer nowrap minWid20Percent svelte-pq8k21");
			attr(span2, "class", "cursor-pointer menu");
			attr(div2, "class", "w100");
			attr(td3, "class", "minWid10Percent text-center svelte-pq8k21");
		},
		m(target, anchor) {
			insert(target, tr, anchor);
			append(tr, td0);
			append(td0, div0);
			append(div0, img0);
			append(div0, t0);
			append(div0, span0);
			append(span0, t1);
			append(span0, t2);
			append(td0, t3);
			append(td0, div1);
			append(div1, img1);
			append(div1, t4);
			append(div1, span1);
			append(span1, t5);
			append(span1, t6);
			append(tr, t7);
			append(tr, td1);
			append(td1, t8);
			append(tr, t9);
			append(tr, td2);
			append(td2, t10);
			append(tr, t11);
			append(tr, td3);
			append(td3, div2);
			append(div2, span2);

			if (!mounted) {
				dispose = [
					listen(td0, "click", function () {
						if (is_function(/*click*/ ctx[1](/*item*/ ctx[0].uuid))) /*click*/ ctx[1](/*item*/ ctx[0].uuid).apply(this, arguments);
					}),
					listen(td1, "click", function () {
						if (is_function(/*click*/ ctx[1](/*item*/ ctx[0].uuid))) /*click*/ ctx[1](/*item*/ ctx[0].uuid).apply(this, arguments);
					}),
					listen(td2, "click", function () {
						if (is_function(/*click*/ ctx[1](/*item*/ ctx[0].uuid))) /*click*/ ctx[1](/*item*/ ctx[0].uuid).apply(this, arguments);
					}),
					listen(span2, "click", stop_propagation(/*toProperties*/ ctx[2]))
				];

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (dirty & /*item*/ 1 && img0_alt_value !== (img0_alt_value = /*item*/ ctx[0].icon[0])) {
				attr(img0, "alt", img0_alt_value);
			}

			if (dirty & /*item*/ 1 && !src_url_equal(img0.src, img0_src_value = /*item*/ ctx[0].icon[0])) {
				attr(img0, "src", img0_src_value);
			}

			if (dirty & /*item*/ 1 && t1_value !== (t1_value = /*item*/ ctx[0].icon[2] + "")) set_data(t1, t1_value);
			if (dirty & /*item*/ 1 && t2_value !== (t2_value = /*item*/ ctx[0].name + "")) set_data(t2, t2_value);

			if (dirty & /*item*/ 1 && img1_alt_value !== (img1_alt_value = /*item*/ ctx[0].icon[0])) {
				attr(img1, "alt", img1_alt_value);
			}

			if (dirty & /*item*/ 1 && !src_url_equal(img1.src, img1_src_value = /*item*/ ctx[0].icon[0])) {
				attr(img1, "src", img1_src_value);
			}

			if (dirty & /*item*/ 1 && t5_value !== (t5_value = /*item*/ ctx[0].icon[2] + "")) set_data(t5, t5_value);
			if (dirty & /*item*/ 1 && t6_value !== (t6_value = /*item*/ ctx[0].name + "")) set_data(t6, t6_value);
			if (dirty & /*item*/ 1 && t8_value !== (t8_value = /*item*/ ctx[0].size + "")) set_data(t8, t8_value);
			if (dirty & /*item*/ 1 && t10_value !== (t10_value = /*item*/ ctx[0].chDate + "")) set_data(t10, t10_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(tr);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$k($$self, $$props, $$invalidate) {
	let { item } = $$props;
	const dispatch = createEventDispatcher();

	function click(uuid) {
		return e => {
			dispatch("openItem", { uuid });
		};
	}

	function toProperties() {
		dispatch("openPropsModal", { file: item });
	}

	$$self.$$set = $$props => {
		if ('item' in $$props) $$invalidate(0, item = $$props.item);
	};

	return [item, click, toProperties];
}

class ListRow extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$k, create_fragment$k, safe_not_equal, { item: 0 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/FileManager/List.svelte generated by Svelte v3.53.1 */

const { Map: Map_1 } = globals;

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i];
	return child_ctx;
}

// (71:8) {#each itemList as item (item.uuid)}
function create_each_block$1(key_1, ctx) {
	let first;
	let listrow;
	let current;
	listrow = new ListRow({ props: { item: /*item*/ ctx[13] } });
	listrow.$on("openItem", /*openItem_handler*/ ctx[5]);
	listrow.$on("reload", /*reload_handler*/ ctx[6]);
	listrow.$on("openPropsModal", /*openPropsModal_handler*/ ctx[7]);

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			create_component(listrow.$$.fragment);
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			mount_component(listrow, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const listrow_changes = {};
			if (dirty & /*itemList*/ 2) listrow_changes.item = /*item*/ ctx[13];
			listrow.$set(listrow_changes);
		},
		i(local) {
			if (current) return;
			transition_in(listrow.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(listrow.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			destroy_component(listrow, detaching);
		}
	};
}

function create_fragment$j(ctx) {
	let div;
	let table;
	let tr;
	let th0;
	let html_tag;
	let raw0_value = /*getCaret*/ ctx[3](/*WHERES*/ ctx[2].NAME, /*sorter*/ ctx[0]) + "";
	let t0;
	let t1;
	let th1;
	let html_tag_1;
	let raw1_value = /*getCaret*/ ctx[3](/*WHERES*/ ctx[2].SIZE, /*sorter*/ ctx[0]) + "";
	let t2;
	let t3;
	let th2;
	let html_tag_2;
	let raw2_value = /*getCaret*/ ctx[3](/*WHERES*/ ctx[2].DATE, /*sorter*/ ctx[0]) + "";
	let t4;
	let t5;
	let each_blocks = [];
	let each_1_lookup = new Map_1();
	let current;
	let mounted;
	let dispose;
	let each_value = /*itemList*/ ctx[1];
	const get_key = ctx => /*item*/ ctx[13].uuid;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$1(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
	}

	return {
		c() {
			div = element("div");
			table = element("table");
			tr = element("tr");
			th0 = element("th");
			html_tag = new HtmlTag(false);
			t0 = text("\n                Name");
			t1 = space();
			th1 = element("th");
			html_tag_1 = new HtmlTag(false);
			t2 = text("Size");
			t3 = space();
			th2 = element("th");
			html_tag_2 = new HtmlTag(false);
			t4 = text("Mod. Date");
			t5 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			html_tag.a = t0;
			attr(th0, "class", "noSelect cursor-pointer");
			html_tag_1.a = t2;
			html_tag_2.a = t4;
			attr(th2, "class", "hide-sm-down");
			attr(table, "class", "table");
			attr(div, "class", "table-responsive w100");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, table);
			append(table, tr);
			append(tr, th0);
			html_tag.m(raw0_value, th0);
			append(th0, t0);
			append(tr, t1);
			append(tr, th1);
			html_tag_1.m(raw1_value, th1);
			append(th1, t2);
			append(tr, t3);
			append(tr, th2);
			html_tag_2.m(raw2_value, th2);
			append(th2, t4);
			append(table, t5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(table, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(th0, "click", /*chSorter*/ ctx[4](/*WHERES*/ ctx[2].NAME)),
					listen(th1, "click", /*chSorter*/ ctx[4](/*WHERES*/ ctx[2].SIZE)),
					listen(th2, "click", /*chSorter*/ ctx[4](/*WHERES*/ ctx[2].DATE))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*sorter*/ 1) && raw0_value !== (raw0_value = /*getCaret*/ ctx[3](/*WHERES*/ ctx[2].NAME, /*sorter*/ ctx[0]) + "")) html_tag.p(raw0_value);
			if ((!current || dirty & /*sorter*/ 1) && raw1_value !== (raw1_value = /*getCaret*/ ctx[3](/*WHERES*/ ctx[2].SIZE, /*sorter*/ ctx[0]) + "")) html_tag_1.p(raw1_value);
			if ((!current || dirty & /*sorter*/ 1) && raw2_value !== (raw2_value = /*getCaret*/ ctx[3](/*WHERES*/ ctx[2].DATE, /*sorter*/ ctx[0]) + "")) html_tag_2.p(raw2_value);

			if (dirty & /*itemList*/ 2) {
				each_value = /*itemList*/ ctx[1];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, table, outro_and_destroy_block, create_each_block$1, null, get_each_context$1);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

const CARET_DOWN = '<span class="monospace font-s1">️ᐁ&nbsp;</span>';
const CARET_UP = '<span class="monospace font-s1">ᐃ&nbsp;</span>';
const CARET_NO = '<span class="monospace font-s1">&nbsp;&nbsp;</span>';

function instance$j($$self, $$props, $$invalidate) {
	let { itemList } = $$props;
	let { sorter } = $$props;
	const CARETS = [CARET_UP, CARET_DOWN];
	const WHERES = { NAME: "N", DATE: "D", SIZE: "S" };
	const SORTERS_DECODED = new Map();
	SORTERS_DECODED.set(SORTERS.ABC, [WHERES.NAME, 0]);
	SORTERS_DECODED.set(SORTERS.CBA, [WHERES.NAME, 1]);
	SORTERS_DECODED.set(SORTERS.OldFirst, [WHERES.DATE, 0]);
	SORTERS_DECODED.set(SORTERS.OldLast, [WHERES.DATE, 1]);
	SORTERS_DECODED.set(SORTERS.SmallFirst, [WHERES.SIZE, 0]);
	SORTERS_DECODED.set(SORTERS.SmallLast, [WHERES.SIZE, 1]);
	const SORTERS_BY_COORDS = new Map();
	SORTERS_BY_COORDS.set(WHERES.NAME, [SORTERS.ABC, SORTERS.CBA]);
	SORTERS_BY_COORDS.set(WHERES.DATE, [SORTERS.OldFirst, SORTERS.OldLast]);
	SORTERS_BY_COORDS.set(WHERES.SIZE, [SORTERS.SmallFirst, SORTERS.SmallLast]);
	let sortingWhere;
	let sortingHow;

	function getCaret(where) {
		if (sortingWhere != where) return CARET_NO;
		return CARETS[sortingHow];
	}

	function chSorter(where) {
		return function () {
			if (sortingWhere == where) {
				sortingHow = 1 - sortingHow;
			} else {
				sortingWhere = where;
				sortingHow = 0;
			}

			$$invalidate(0, sorter = SORTERS_BY_COORDS.get(sortingWhere)[sortingHow]);
		};
	}

	function openItem_handler(event) {
		bubble.call(this, $$self, event);
	}

	function reload_handler(event) {
		bubble.call(this, $$self, event);
	}

	function openPropsModal_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('itemList' in $$props) $$invalidate(1, itemList = $$props.itemList);
		if ('sorter' in $$props) $$invalidate(0, sorter = $$props.sorter);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*sorter*/ 1) {
			{
				[sortingWhere, sortingHow] = SORTERS_DECODED.get(sorter);
			}
		}
	};

	return [
		sorter,
		itemList,
		WHERES,
		getCaret,
		chSorter,
		openItem_handler,
		reload_handler,
		openPropsModal_handler
	];
}

class List extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$j, create_fragment$j, safe_not_equal, { itemList: 1, sorter: 0 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/Utils.svelte generated by Svelte v3.53.1 */

function getCookie(cName) {
	const name = cName + "=";
	const vals = decodeURIComponent(document.cookie).split("; ");

	for (let i = 0; i < vals.length; i++) {
		if (vals[i].indexOf(name) == 0) return vals[i].substring(name.length);
	}

	return "";
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconGrid.svelte generated by Svelte v3.53.1 */

function create_fragment$i(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M3 11H11V3H3M5 5H9V9H5M13 21H21V13H13M15 15H19V19H15M3 21H11V13H3M5 15H9V19H5M13 3V11H21V3M19 9H15V5H19Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$i($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconGrid extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$i, create_fragment$i, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconList.svelte generated by Svelte v3.53.1 */

function create_fragment$h(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M9,5V9H21V5M9,19H21V15H9M9,14H21V10H9M4,9H8V5H4M4,19H8V15H4M4,14H8V10H4V14Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$h($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconList extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$h, create_fragment$h, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconSortAlphAsc.svelte generated by Svelte v3.53.1 */

function create_fragment$g(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M19 17H22L18 21L14 17H17V3H19M11 13V15L7.67 19H11V21H5V19L8.33 15H5V13M9 3H7C5.9 3 5 3.9 5 5V11H7V9H9V11H11V5C11 3.9 10.11 3 9 3M9 7H7V5H9Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$g($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconSortAlphAsc extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$g, create_fragment$g, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconSortAlphDesc.svelte generated by Svelte v3.53.1 */

function create_fragment$f(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M19 7H22L18 3L14 7H17V21H19M11 13V15L7.67 19H11V21H5V19L8.33 15H5V13M9 3H7C5.9 3 5 3.9 5 5V11H7V9H9V11H11V5C11 3.9 10.11 3 9 3M9 7H7V5H9Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$f($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconSortAlphDesc extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$f, create_fragment$f, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconSortDateAsc.svelte generated by Svelte v3.53.1 */

function create_fragment$e(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M21 17H24L20 21L16 17H19V3H21V17M8 16H11V13H8V16M13 5H12V3H10V5H6V3H4V5H3C1.89 5 1 5.89 1 7V18C1 19.11 1.89 20 3 20H13C14.11 20 15 19.11 15 18V7C15 5.89 14.11 5 13 5M3 18L3 11H13L13 18L3 18Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$e($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconSortDateAsc extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$e, create_fragment$e, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconSortDateDesc.svelte generated by Svelte v3.53.1 */

function create_fragment$d(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M19 7H16L20 3L24 7H21V21H19V7M8 16H11V13H8V16M13 5H12V3H10V5H6V3H4V5H3C1.89 5 1 5.89 1 7V18C1 19.11 1.89 20 3 20H13C14.11 20 15 19.11 15 18V7C15 5.89 14.11 5 13 5M3 18L3 11H13L13 18L3 18Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$d($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconSortDateDesc extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$d, create_fragment$d, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconSortSizeAsc.svelte generated by Svelte v3.53.1 */

function create_fragment$c(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M19 17H22L18 21L14 17H17V3H19M2 17H12V19H2M6 5V7H2V5M2 11H9V13H2V11Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconSortSizeAsc extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$c, create_fragment$c, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconSortSizeDesc.svelte generated by Svelte v3.53.1 */

function create_fragment$b(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M19 7H22L18 3L14 7H17V21H19M2 17H12V19H2M6 5V7H2V5M2 11H9V13H2V11Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconSortSizeDesc extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$b, create_fragment$b, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconPaste.svelte generated by Svelte v3.53.1 */

function create_fragment$a(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M19,20H5V4H7V7H17V4H19M12,2A1,1 0 0,1 13,3A1,1 0 0,1 12,4A1,1 0 0,1 11,3A1,1 0 0,1 12,2M19,2H14.82C14.4,0.84 13.3,0 12,0C10.7,0 9.6,0.84 9.18,2H5A2,2 0 0,0 3,4V20A2,2 0 0,0 5,22H19A2,2 0 0,0 21,20V4A2,2 0 0,0 19,2Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconPaste extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconUnpaste.svelte generated by Svelte v3.53.1 */

function create_fragment$9(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M3.27,1L2,2.27L6.22,6.5L3,9L4.63,10.27L12,16L14.1,14.37L15.53,15.8L12,18.54L4.63,12.81L3,14.07L12,21.07L16.95,17.22L20.73,21L22,19.73L3.27,1M19.36,10.27L21,9L12,2L9.09,4.27L16.96,12.15L19.36,10.27M19.81,15L21,14.07L19.57,12.64L18.38,13.56L19.81,15Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconUnpaste extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconNewFolder.svelte generated by Svelte v3.53.1 */

function create_fragment$8(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M12 12H14V10H16V12H18V14H16V16H14V14H12V12M22 8V18C22 19.11 21.11 20 20 20H4C2.89 20 2 19.11 2 18V6C2 4.89 2.89 4 4 4H10L12 6H20C21.11 6 22 6.89 22 8M20 8H4V18H20V8Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconNewFolder extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconUpload.svelte generated by Svelte v3.53.1 */

function create_fragment$7(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M19.35,10.04C18.67,6.59 15.64,4 12,4C9.11,4 6.6,5.64 5.35,8.04C2.34,8.36 0,10.91 0,14A6,6 0 0,0 6,20H19A5,5 0 0,0 24,15C24,12.36 21.95,10.22 19.35,10.04M19,18H6A4,4 0 0,1 2,14C2,11.95 3.53,10.24 5.56,10.03L6.63,9.92L7.13,8.97C8.08,7.14 9.94,6 12,6C14.62,6 16.88,7.86 17.39,10.43L17.69,11.93L19.22,12.04C20.78,12.14 22,13.45 22,15A3,3 0 0,1 19,18M8,13H10.55V16H13.45V13H16L12,9L8,13Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconUpload extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconReload.svelte generated by Svelte v3.53.1 */

function create_fragment$6(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M2 12C2 16.97 6.03 21 11 21C13.39 21 15.68 20.06 17.4 18.4L15.9 16.9C14.63 18.25 12.86 19 11 19C4.76 19 1.64 11.46 6.05 7.05C10.46 2.64 18 5.77 18 12H15L19 16H19.1L23 12H20C20 7.03 15.97 3 11 3C6.03 3 2 7.03 2 12Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconReload extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconShare.svelte generated by Svelte v3.53.1 */

function create_fragment$5(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M18 16.08C17.24 16.08 16.56 16.38 16.04 16.85L8.91 12.7C8.96 12.47 9 12.24 9 12S8.96 11.53 8.91 11.3L15.96 7.19C16.5 7.69 17.21 8 18 8C19.66 8 21 6.66 21 5S19.66 2 18 2 15 3.34 15 5C15 5.24 15.04 5.47 15.09 5.7L8.04 9.81C7.5 9.31 6.79 9 6 9C4.34 9 3 10.34 3 12S4.34 15 6 15C6.79 15 7.5 14.69 8.04 14.19L15.16 18.34C15.11 18.55 15.08 18.77 15.08 19C15.08 20.61 16.39 21.91 18 21.91S20.92 20.61 20.92 19C20.92 17.39 19.61 16.08 18 16.08M18 4C18.55 4 19 4.45 19 5S18.55 6 18 6 17 5.55 17 5 17.45 4 18 4M6 13C5.45 13 5 12.55 5 12S5.45 11 6 11 7 11.45 7 12 6.55 13 6 13M18 20C17.45 20 17 19.55 17 19S17.45 18 18 18 19 18.45 19 19 18.55 20 18 20Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconShare extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/Snippets/Properties.svelte generated by Svelte v3.53.1 */

function create_if_block$3(ctx) {
	let div4;
	let div0;
	let t1;
	let div1;
	let t3;
	let div2;
	let t5;
	let div3;
	let t7;
	let div12;
	let div7;
	let div5;
	let t9;
	let div6;
	let t11;
	let div8;
	let t13;
	let div11;
	let div9;
	let t15;
	let div10;
	let mounted;
	let dispose;

	return {
		c() {
			div4 = element("div");
			div0 = element("div");
			div0.textContent = "Cut";
			t1 = space();
			div1 = element("div");
			div1.textContent = "Copy";
			t3 = space();
			div2 = element("div");
			div2.textContent = "Rename";
			t5 = space();
			div3 = element("div");
			div3.textContent = "Delete";
			t7 = space();
			div12 = element("div");
			div7 = element("div");
			div5 = element("div");
			div5.textContent = "Cut";
			t9 = space();
			div6 = element("div");
			div6.textContent = "Copy";
			t11 = space();
			div8 = element("div");
			div8.textContent = " ";
			t13 = space();
			div11 = element("div");
			div9 = element("div");
			div9.textContent = "Rename";
			t15 = space();
			div10 = element("div");
			div10.textContent = "Delete";
			attr(div0, "class", "btn primary");
			attr(div1, "class", "btn primary");
			attr(div2, "class", "btn primary");
			attr(div3, "class", "btn error");
			attr(div4, "class", "btn-group btn-group-small rounded-1 hide-xs mx-auto");
			attr(div5, "class", "btn primary");
			attr(div6, "class", "btn primary");
			attr(div7, "class", "btn-group btn-group-small rounded-1 mx-auto");
			attr(div9, "class", "btn primary");
			attr(div10, "class", "btn error");
			attr(div11, "class", "btn-group btn-group-small rounded-1 mx-auto");
			attr(div12, "class", "hide-sm-up");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div0);
			append(div4, t1);
			append(div4, div1);
			append(div4, t3);
			append(div4, div2);
			append(div4, t5);
			append(div4, div3);
			insert(target, t7, anchor);
			insert(target, div12, anchor);
			append(div12, div7);
			append(div7, div5);
			append(div7, t9);
			append(div7, div6);
			append(div12, t11);
			append(div12, div8);
			append(div12, t13);
			append(div12, div11);
			append(div11, div9);
			append(div11, t15);
			append(div11, div10);

			if (!mounted) {
				dispose = [
					listen(div0, "click", stop_propagation(/*toPaste*/ ctx[4](true))),
					listen(div1, "click", stop_propagation(/*toPaste*/ ctx[4](false))),
					listen(div2, "click", stop_propagation(/*rename*/ ctx[2])),
					listen(div3, "click", stop_propagation(/*del*/ ctx[3])),
					listen(div5, "click", stop_propagation(/*toPaste*/ ctx[4](true))),
					listen(div6, "click", stop_propagation(/*toPaste*/ ctx[4](false))),
					listen(div9, "click", stop_propagation(/*rename*/ ctx[2])),
					listen(div10, "click", stop_propagation(/*del*/ ctx[3]))
				];

				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div4);
			if (detaching) detach(t7);
			if (detaching) detach(div12);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$4(ctx) {
	let div3;
	let div0;
	let img;
	let img_alt_value;
	let img_src_value;
	let t0;
	let t1_value = /*item*/ ctx[0].name + "";
	let t1;
	let t2;
	let div2;
	let p0;
	let b0;
	let t4;
	let span;
	let t5_value = /*item*/ ctx[0].name + "";
	let t5;
	let span_title_value;
	let t6;
	let p1;
	let b1;
	let t8;
	let t9_value = /*item*/ ctx[0].size + "";
	let t9;
	let t10;
	let p2;
	let b2;
	let t12;
	let t13_value = /*item*/ ctx[0].chDate + "";
	let t13;
	let t14;
	let p3;
	let b3;
	let t16;
	let t17_value = /*item*/ ctx[0].mimeType + "";
	let t17;
	let t18;
	let p4;
	let b4;
	let t20;
	let t21_value = /*item*/ ctx[0].owner + "";
	let t21;
	let t22;
	let p5;
	let b5;
	let t24;
	let t25_value = /*item*/ ctx[0].group + "";
	let t25;
	let t26;
	let p6;
	let b6;
	let t28;
	let t29_value = /*item*/ ctx[0].permissions + "";
	let t29;
	let t30;
	let div1;
	let t32;
	let if_block = !/*readOnly*/ ctx[1] && (!/*item*/ ctx[0].isDir || /*item*/ ctx[0].name != '../') && create_if_block$3(ctx);

	return {
		c() {
			div3 = element("div");
			div0 = element("div");
			img = element("img");
			t0 = text(" ");
			t1 = text(t1_value);
			t2 = space();
			div2 = element("div");
			p0 = element("p");
			b0 = element("b");
			b0.textContent = "File name:";
			t4 = space();
			span = element("span");
			t5 = text(t5_value);
			t6 = space();
			p1 = element("p");
			b1 = element("b");
			b1.textContent = "Size:";
			t8 = space();
			t9 = text(t9_value);
			t10 = space();
			p2 = element("p");
			b2 = element("b");
			b2.textContent = "Mod. date:";
			t12 = space();
			t13 = text(t13_value);
			t14 = space();
			p3 = element("p");
			b3 = element("b");
			b3.textContent = "Type:";
			t16 = space();
			t17 = text(t17_value);
			t18 = space();
			p4 = element("p");
			b4 = element("b");
			b4.textContent = "Owner:";
			t20 = space();
			t21 = text(t21_value);
			t22 = space();
			p5 = element("p");
			b5 = element("b");
			b5.textContent = "Group:";
			t24 = space();
			t25 = text(t25_value);
			t26 = space();
			p6 = element("p");
			b6 = element("b");
			b6.textContent = "Permissions:";
			t28 = space();
			t29 = text(t29_value);
			t30 = space();
			div1 = element("div");
			div1.textContent = " ";
			t32 = space();
			if (if_block) if_block.c();
			attr(img, "class", "darkmode-invert");
			attr(img, "alt", img_alt_value = /*item*/ ctx[0].icon[0]);
			if (!src_url_equal(img.src, img_src_value = /*item*/ ctx[0].icon[0])) attr(img, "src", img_src_value);
			attr(div0, "class", "modal-header ellipsis");
			attr(span, "title", span_title_value = /*item*/ ctx[0].name);
			attr(p0, "class", "ellipsis");
			attr(p1, "class", "ellipsis");
			attr(p2, "class", "ellipsis");
			attr(p3, "class", "ellipsis");
			attr(p4, "class", "ellipsis");
			attr(p5, "class", "ellipsis");
			attr(p6, "class", "ellipsis");
			attr(div2, "class", "modal-content container");
			attr(div3, "class", "modal shadow-1 white rounded-3 modal-bouncing");
			attr(div3, "id", "modal-properties");
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div0);
			append(div0, img);
			append(div0, t0);
			append(div0, t1);
			append(div3, t2);
			append(div3, div2);
			append(div2, p0);
			append(p0, b0);
			append(p0, t4);
			append(p0, span);
			append(span, t5);
			append(div2, t6);
			append(div2, p1);
			append(p1, b1);
			append(p1, t8);
			append(p1, t9);
			append(div2, t10);
			append(div2, p2);
			append(p2, b2);
			append(p2, t12);
			append(p2, t13);
			append(div2, t14);
			append(div2, p3);
			append(p3, b3);
			append(p3, t16);
			append(p3, t17);
			append(div2, t18);
			append(div2, p4);
			append(p4, b4);
			append(p4, t20);
			append(p4, t21);
			append(div2, t22);
			append(div2, p5);
			append(p5, b5);
			append(p5, t24);
			append(p5, t25);
			append(div2, t26);
			append(div2, p6);
			append(p6, b6);
			append(p6, t28);
			append(p6, t29);
			append(div2, t30);
			append(div2, div1);
			append(div2, t32);
			if (if_block) if_block.m(div2, null);
		},
		p(ctx, [dirty]) {
			if (dirty & /*item*/ 1 && img_alt_value !== (img_alt_value = /*item*/ ctx[0].icon[0])) {
				attr(img, "alt", img_alt_value);
			}

			if (dirty & /*item*/ 1 && !src_url_equal(img.src, img_src_value = /*item*/ ctx[0].icon[0])) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*item*/ 1 && t1_value !== (t1_value = /*item*/ ctx[0].name + "")) set_data(t1, t1_value);
			if (dirty & /*item*/ 1 && t5_value !== (t5_value = /*item*/ ctx[0].name + "")) set_data(t5, t5_value);

			if (dirty & /*item*/ 1 && span_title_value !== (span_title_value = /*item*/ ctx[0].name)) {
				attr(span, "title", span_title_value);
			}

			if (dirty & /*item*/ 1 && t9_value !== (t9_value = /*item*/ ctx[0].size + "")) set_data(t9, t9_value);
			if (dirty & /*item*/ 1 && t13_value !== (t13_value = /*item*/ ctx[0].chDate + "")) set_data(t13, t13_value);
			if (dirty & /*item*/ 1 && t17_value !== (t17_value = /*item*/ ctx[0].mimeType + "")) set_data(t17, t17_value);
			if (dirty & /*item*/ 1 && t21_value !== (t21_value = /*item*/ ctx[0].owner + "")) set_data(t21, t21_value);
			if (dirty & /*item*/ 1 && t25_value !== (t25_value = /*item*/ ctx[0].group + "")) set_data(t25, t25_value);
			if (dirty & /*item*/ 1 && t29_value !== (t29_value = /*item*/ ctx[0].permissions + "")) set_data(t29, t29_value);

			if (!/*readOnly*/ ctx[1] && (!/*item*/ ctx[0].isDir || /*item*/ ctx[0].name != '../')) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(div2, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div3);
			if (if_block) if_block.d();
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { item } = $$props;
	let { readOnly } = $$props;
	const dispatch = createEventDispatcher();
	let modal = null;

	onMount(() => {
		modal = new pn("#modal-properties", { bodyScrolling: true });
		const modalQuery = document.querySelector("#modal-properties");

		modalQuery.addEventListener("ax.modal.closed", function () {
			ma("#modal-properties");
			dispatch("closePropsModal");
		});

		modal.open();
	});

	async function rename() {
		const { value: nuName } = await Swal.fire({
			titleText: "Enter new name",
			confirmButtonColor: "#0a6bb8",
			showCancelButton: true,
			input: "text",
			inputValue: item.name.replaceAll("/", ""),
			inputAttributes: {
				autocapitalize: "off",
				autocorrect: "off"
			}
		});

		if (!nuName) {
			return;
		}

		if (item.name == nuName) {
			await Swal.fire({
				icon: "error",
				text: "Old and new name must be different",
				confirmButtonColor: "#0a6bb8"
			});

			return;
		}

		const res = await fetch("fsOps/rename?path=" + encodeURIComponent(item.path) + "&name=" + encodeURIComponent(nuName), {
			method: "POST",
			headers: { "X-Csrf-Token": getCookie("csrf_") }
		});

		if (res.status != 200) {
			await Swal.fire({
				icon: "error",
				text: await res.text(),
				confirmButtonColor: "#0a6bb8"
			});
		} else {
			await Swal.fire({
				icon: "success",
				titleText: "Done!",
				confirmButtonColor: "#0a6bb8"
			});

			modal.close();
			dispatch("reload", {});
		}
	}

	async function del() {
		const { value: confirm } = await Swal.fire({
			html: "Do you really want to delete<br/><code>" + item.path + "</code>&nbsp;?",
			icon: "question",
			confirmButtonColor: "#0a6bb8",
			showCancelButton: true,
			cancelButtonText: "No"
		});

		if (!confirm) {
			return;
		}

		const res = await fetch("fsOps/del?path=" + encodeURIComponent(item.path), {
			method: "DELETE",
			headers: { "X-Csrf-Token": getCookie("csrf_") }
		});

		if (res.status != 200) {
			await Swal.fire({
				icon: "error",
				text: await res.text(),
				confirmButtonColor: "#0a6bb8"
			});
		} else {
			await Swal.fire({
				icon: "success",
				titleText: "Done!",
				confirmButtonColor: "#0a6bb8"
			});

			modal.close();
		}
	}

	function toPaste(isCut) {
		return function () {
			dispatch("toPaste", { file: item, isCut });
			modal.close();
		};
	}

	$$self.$$set = $$props => {
		if ('item' in $$props) $$invalidate(0, item = $$props.item);
		if ('readOnly' in $$props) $$invalidate(1, readOnly = $$props.readOnly);
	};

	return [item, readOnly, rename, del, toPaste];
}

class Properties extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { item: 0, readOnly: 1 });
	}
}

const Sharing_svelte_svelte_type_style_lang = '';

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/Snippets/Sharing.svelte generated by Svelte v3.53.1 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[18] = i;
	return child_ctx;
}

// (86:24) {#each config.sharing.profiles as prf, idx}
function create_each_block(ctx) {
	let option;
	let t_value = /*prf*/ ctx[16] + "";
	let t;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = /*idx*/ ctx[18];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty & /*config*/ 1 && t_value !== (t_value = /*prf*/ ctx[16] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (108:16) {#if expires}
function create_if_block_2$1(ctx) {
	let div;
	let label;
	let t1;
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			label = element("label");
			label.textContent = " ";
			t1 = space();
			input = element("input");
			attr(label, "for", "date");
			attr(input, "type", "date");
			attr(input, "id", "date");
			attr(input, "class", "form-control rounded-1");
			set_style(input, "margin-top", "-8px");
			attr(div, "class", "form-field");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, label);
			append(div, t1);
			append(div, input);
			set_input_value(input, /*expiryDate*/ ctx[3]);

			if (!mounted) {
				dispose = listen(input, "input", /*input_input_handler*/ ctx[14]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*expiryDate*/ 8) {
				set_input_value(input, /*expiryDate*/ ctx[3]);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (122:8) {#if !!error}
function create_if_block_1$2(ctx) {
	let div;
	let t;
	let div_transition;
	let current;

	return {
		c() {
			div = element("div");
			t = text(/*error*/ ctx[2]);
			attr(div, "class", "p-3 my-2 rounded-2 red light-3 text-red text-dark-4");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*error*/ 4) set_data(t, /*error*/ ctx[2]);
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
				div_transition.run(1);
			});

			current = true;
		},
		o(local) {
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
			div_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (detaching && div_transition) div_transition.end();
		}
	};
}

// (127:8) {#if !!link}
function create_if_block$2(ctx) {
	let div;
	let t;
	let div_transition;
	let current;

	return {
		c() {
			div = element("div");
			t = text(/*link*/ ctx[1]);
			attr(div, "class", "p-3 my-2 rounded-2 viride light-4 monospace svelte-4ly2lq");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*link*/ 2) set_data(t, /*link*/ ctx[1]);
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
				div_transition.run(1);
			});

			current = true;
		},
		o(local) {
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
			div_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (detaching && div_transition) div_transition.end();
		}
	};
}

function create_fragment$3(ctx) {
	let div12;
	let div0;
	let t1;
	let div9;
	let form;
	let div4;
	let div2;
	let label0;
	let t3;
	let input0;
	let t4;
	let div1;
	let t6;
	let div3;
	let label1;
	let t8;
	let select;
	let t9;
	let div8;
	let div6;
	let label2;
	let t11;
	let label3;
	let input1;
	let t12;
	let span0;
	let t13;
	let t14;
	let div5;
	let t16;
	let div7;
	let label4;
	let t18;
	let label5;
	let input2;
	let t19;
	let span1;
	let t20;
	let t21;
	let t22;
	let div11;
	let div10;
	let t24;
	let t25;
	let current;
	let mounted;
	let dispose;
	let each_value = /*config*/ ctx[0].sharing.profiles;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	let if_block0 = /*expires*/ ctx[4] && create_if_block_2$1(ctx);
	let if_block1 = !!/*error*/ ctx[2] && create_if_block_1$2(ctx);
	let if_block2 = !!/*link*/ ctx[1] && create_if_block$2(ctx);

	return {
		c() {
			div12 = element("div");
			div0 = element("div");
			div0.textContent = "Sharing";
			t1 = space();
			div9 = element("div");
			form = element("form");
			div4 = element("div");
			div2 = element("div");
			label0 = element("label");
			label0.textContent = "Password";
			t3 = space();
			input0 = element("input");
			t4 = space();
			div1 = element("div");
			div1.textContent = " ";
			t6 = space();
			div3 = element("div");
			label1 = element("label");
			label1.textContent = "Profile";
			t8 = space();
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t9 = space();
			div8 = element("div");
			div6 = element("div");
			label2 = element("label");
			label2.textContent = " ";
			t11 = space();
			label3 = element("label");
			input1 = element("input");
			t12 = space();
			span0 = element("span");
			t13 = text(" Read Only");
			t14 = space();
			div5 = element("div");
			div5.textContent = " ";
			t16 = space();
			div7 = element("div");
			label4 = element("label");
			label4.textContent = " ";
			t18 = space();
			label5 = element("label");
			input2 = element("input");
			t19 = space();
			span1 = element("span");
			t20 = text(" Expires");
			t21 = space();
			if (if_block0) if_block0.c();
			t22 = space();
			div11 = element("div");
			div10 = element("div");
			div10.textContent = "Generate link";
			t24 = space();
			if (if_block1) if_block1.c();
			t25 = space();
			if (if_block2) if_block2.c();
			attr(div0, "class", "modal-header text-center");
			attr(label0, "for", "shPassword");
			attr(input0, "type", "password");
			attr(input0, "id", "shPassword");
			attr(input0, "class", "form-control rounded-1");
			attr(input0, "placeholder", "Leave empty for no password");
			attr(div2, "class", "form-field");
			attr(label1, "for", "profile");
			attr(select, "class", "form-control rounded-1");
			attr(select, "id", "profile");
			if (/*profile*/ ctx[5] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[11].call(select));
			attr(div3, "class", "form-field");
			attr(div4, "class", "grix xs1 lg2 gutter-lg2");
			attr(label2, "for", "ro");
			attr(input1, "type", "checkbox");
			attr(input1, "id", "ro");
			attr(span0, "class", "form-slider");
			attr(label3, "class", "form-switch mx-auto");
			attr(div6, "class", "form-field");
			attr(label4, "for", "exp");
			attr(input2, "type", "checkbox");
			attr(input2, "id", "exp");
			attr(span1, "class", "form-slider");
			attr(label5, "class", "form-switch mx-auto");
			attr(div7, "class", "form-field");
			attr(div8, "class", "grix xs1 lg3 gutter-lg2");
			attr(div9, "class", "modal-content container");
			attr(div10, "class", "btn btn-small rounded-1 primary mb-3");
			attr(div11, "class", "modal-footer w-100 text-center");
			attr(div12, "class", "modal shadow-1 white rounded-3");
			attr(div12, "id", "modal-share");
		},
		m(target, anchor) {
			insert(target, div12, anchor);
			append(div12, div0);
			append(div12, t1);
			append(div12, div9);
			append(div9, form);
			append(form, div4);
			append(div4, div2);
			append(div2, label0);
			append(div2, t3);
			append(div2, input0);
			set_input_value(input0, /*shPassword*/ ctx[7]);
			append(div2, t4);
			append(div2, div1);
			append(div4, t6);
			append(div4, div3);
			append(div3, label1);
			append(div3, t8);
			append(div3, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*profile*/ ctx[5]);
			append(form, t9);
			append(form, div8);
			append(div8, div6);
			append(div6, label2);
			append(div6, t11);
			append(div6, label3);
			append(label3, input1);
			input1.checked = /*readOnly*/ ctx[6];
			append(label3, t12);
			append(label3, span0);
			append(label3, t13);
			append(div6, t14);
			append(div6, div5);
			append(div8, t16);
			append(div8, div7);
			append(div7, label4);
			append(div7, t18);
			append(div7, label5);
			append(label5, input2);
			input2.checked = /*expires*/ ctx[4];
			append(label5, t19);
			append(label5, span1);
			append(label5, t20);
			append(div8, t21);
			if (if_block0) if_block0.m(div8, null);
			append(div12, t22);
			append(div12, div11);
			append(div11, div10);
			append(div11, t24);
			if (if_block1) if_block1.m(div11, null);
			append(div11, t25);
			if (if_block2) if_block2.m(div11, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input0, "input", /*input0_input_handler*/ ctx[10]),
					listen(select, "change", /*select_change_handler*/ ctx[11]),
					listen(input1, "change", /*input1_change_handler*/ ctx[12]),
					listen(input2, "change", /*input2_change_handler*/ ctx[13]),
					listen(div10, "click", /*gen*/ ctx[8])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*shPassword*/ 128 && input0.value !== /*shPassword*/ ctx[7]) {
				set_input_value(input0, /*shPassword*/ ctx[7]);
			}

			if (dirty & /*config*/ 1) {
				each_value = /*config*/ ctx[0].sharing.profiles;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*profile*/ 32) {
				select_option(select, /*profile*/ ctx[5]);
			}

			if (dirty & /*readOnly*/ 64) {
				input1.checked = /*readOnly*/ ctx[6];
			}

			if (dirty & /*expires*/ 16) {
				input2.checked = /*expires*/ ctx[4];
			}

			if (/*expires*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$1(ctx);
					if_block0.c();
					if_block0.m(div8, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!!/*error*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*error*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div11, t25);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!!/*link*/ ctx[1]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*link*/ 2) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block$2(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div11, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div12);
			destroy_each(each_blocks, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let shPassword;
	let readOnly;
	let profile;
	let expires;
	let expiryDate;
	let error;
	let link;
	let { dir } = $$props;
	let { config } = $$props;
	const dispatch = createEventDispatcher();

	onMount(() => {
		const modal = new pn("#modal-share", { bodyScrolling: true });
		const modalQuery = document.querySelector("#modal-share");

		modalQuery.addEventListener("ax.modal.closed", function () {
			ma("#modal-share");
			dispatch("closeShareModal");
		});

		modal.open();
	});

	async function gen(event) {
		if (expires && !expiryDate) {
			$$invalidate(2, error = "Please provide an expiry date");
			return;
		}

		$$invalidate(2, error = "");

		const url = "shareLink?pwd=" + encodeURIComponent(shPassword) + "&dir=" + encodeURIComponent(dir) + "&readOnly=" + (readOnly ? "1" : "0") + "&profile=" + encodeURIComponent(config.sharing.profiles[profile]) + (expires
		? "&expiry=" + encodeURIComponent(expiryDate)
		: "");

		const res = await fetch(url);

		if (res.status != 200) {
			$$invalidate(2, error = await res.text());
		} else {
			$$invalidate(1, link = await res.text());
		}
	}

	function input0_input_handler() {
		shPassword = this.value;
		$$invalidate(7, shPassword);
	}

	function select_change_handler() {
		profile = select_value(this);
		$$invalidate(5, profile);
	}

	function input1_change_handler() {
		readOnly = this.checked;
		$$invalidate(6, readOnly);
	}

	function input2_change_handler() {
		expires = this.checked;
		$$invalidate(4, expires);
	}

	function input_input_handler() {
		expiryDate = this.value;
		$$invalidate(3, expiryDate);
	}

	$$self.$$set = $$props => {
		if ('dir' in $$props) $$invalidate(9, dir = $$props.dir);
		if ('config' in $$props) $$invalidate(0, config = $$props.config);
	};

	$$invalidate(7, shPassword = "");
	$$invalidate(6, readOnly = true);
	$$invalidate(5, profile = 0);
	$$invalidate(4, expires = false);
	$$invalidate(3, expiryDate = "");
	$$invalidate(2, error = "");
	$$invalidate(1, link = "");

	return [
		config,
		link,
		error,
		expiryDate,
		expires,
		profile,
		readOnly,
		shPassword,
		gen,
		dir,
		input0_input_handler,
		select_change_handler,
		input1_change_handler,
		input2_change_handler,
		input_input_handler
	];
}

class Sharing extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { dir: 9, config: 0 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/SVG/IconLogout.svelte generated by Svelte v3.53.1 */

function create_fragment$2(ctx) {
	let svg;
	let path;
	let svg_viewBox_value;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill", /*color*/ ctx[1]);
			attr(path, "d", "M14.08,15.59L16.67,13H7V11H16.67L14.08,8.41L15.5,7L20.5,12L15.5,17L14.08,15.59M19,3A2,2 0 0,1 21,5V9.67L19,7.67V5H5V19H19V16.33L21,14.33V19A2,2 0 0,1 19,21H5C3.89,21 3,20.1 3,19V5C3,3.89 3.89,3 5,3H19Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr(svg, "version", "1.1");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*color*/ 2) {
				attr(path, "fill", /*color*/ ctx[1]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = "#000000" } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class IconLogout extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { size: 0, color: 1 });
	}
}

/* src/svelte/components/apps/FileManager/svelte-file-manager/src/FileManager/FileManager.svelte generated by Svelte v3.53.1 */

function create_if_block_13(ctx) {
	let div0;
	let iconpaste;
	let div0_transition;
	let t;
	let div1;
	let iconunpaste;
	let div1_transition;
	let current;
	let mounted;
	let dispose;
	iconpaste = new IconPaste({ props: { color: "#AA0000", size: 24 } });
	iconunpaste = new IconUnpaste({ props: { color: "#AA0000", size: 24 } });

	return {
		c() {
			div0 = element("div");
			create_component(iconpaste.$$.fragment);
			t = space();
			div1 = element("div");
			create_component(iconunpaste.$$.fragment);
			attr(div0, "class", "navbar-link");
			attr(div0, "title", "Paste");
			attr(div1, "class", "navbar-link");
			attr(div1, "title", "Abort paste");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			mount_component(iconpaste, div0, null);
			insert(target, t, anchor);
			insert(target, div1, anchor);
			mount_component(iconunpaste, div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "click", /*doPaste*/ ctx[11]),
					listen(div1, "click", /*unmarkToPaste*/ ctx[10])
				];

				mounted = true;
			}
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(iconpaste.$$.fragment, local);

			add_render_callback(() => {
				if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fade, {}, true);
				div0_transition.run(1);
			});

			transition_in(iconunpaste.$$.fragment, local);

			add_render_callback(() => {
				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, {}, true);
				div1_transition.run(1);
			});

			current = true;
		},
		o(local) {
			transition_out(iconpaste.$$.fragment, local);
			if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fade, {}, false);
			div0_transition.run(0);
			transition_out(iconunpaste.$$.fragment, local);
			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, {}, false);
			div1_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			destroy_component(iconpaste);
			if (detaching && div0_transition) div0_transition.end();
			if (detaching) detach(t);
			if (detaching) detach(div1);
			destroy_component(iconunpaste);
			if (detaching && div1_transition) div1_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (241:8) {#if !config.readOnly}
function create_if_block_12(ctx) {
	let div0;
	let iconnewfolder;
	let t;
	let div1;
	let iconupload;
	let current;
	let mounted;
	let dispose;
	iconnewfolder = new IconNewFolder({ props: { size: 24 } });
	iconupload = new IconUpload({ props: { size: 24 } });

	return {
		c() {
			div0 = element("div");
			create_component(iconnewfolder.$$.fragment);
			t = space();
			div1 = element("div");
			create_component(iconupload.$$.fragment);
			attr(div0, "class", "navbar-link");
			attr(div0, "title", "Create folder");
			attr(div1, "class", "navbar-link");
			attr(div1, "title", "Upload file(s)");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			mount_component(iconnewfolder, div0, null);
			insert(target, t, anchor);
			insert(target, div1, anchor);
			mount_component(iconupload, div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "click", /*newFolder*/ ctx[14]),
					listen(div1, "click", /*doUpload*/ ctx[15])
				];

				mounted = true;
			}
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(iconnewfolder.$$.fragment, local);
			transition_in(iconupload.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconnewfolder.$$.fragment, local);
			transition_out(iconupload.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			destroy_component(iconnewfolder);
			if (detaching) detach(t);
			if (detaching) detach(div1);
			destroy_component(iconupload);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (249:8) {#if config.sharing != null}
function create_if_block_11(ctx) {
	let div;
	let iconshare;
	let current;
	let mounted;
	let dispose;
	iconshare = new IconShare({ props: { size: 24 } });

	return {
		c() {
			div = element("div");
			create_component(iconshare.$$.fragment);
			attr(div, "class", "navbar-link");
			attr(div, "title", "Share link for this folder");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(iconshare, div, null);
			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*doOpenSharingModal*/ ctx[19]);
				mounted = true;
			}
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(iconshare.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconshare.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(iconshare);
			mounted = false;
			dispose();
		}
	};
}

// (260:12) {:else}
function create_else_block_1(ctx) {
	let iconlist;
	let current;
	iconlist = new IconList({ props: { size: 24 } });

	return {
		c() {
			create_component(iconlist.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconlist, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconlist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconlist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconlist, detaching);
		}
	};
}

// (258:12) {#if mode == 'GRID'}
function create_if_block_10(ctx) {
	let icongrid;
	let current;
	icongrid = new IconGrid({ props: { size: 24 } });

	return {
		c() {
			create_component(icongrid.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icongrid, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(icongrid.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icongrid.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icongrid, detaching);
		}
	};
}

// (276:54) 
function create_if_block_9(ctx) {
	let iconsortsizedesc;
	let current;
	iconsortsizedesc = new IconSortSizeDesc({ props: { size: 24 } });

	return {
		c() {
			create_component(iconsortsizedesc.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconsortsizedesc, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconsortsizedesc.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconsortsizedesc.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconsortsizedesc, detaching);
		}
	};
}

// (274:55) 
function create_if_block_8(ctx) {
	let iconsortsizeasc;
	let current;
	iconsortsizeasc = new IconSortSizeAsc({ props: { size: 24 } });

	return {
		c() {
			create_component(iconsortsizeasc.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconsortsizeasc, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconsortsizeasc.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconsortsizeasc.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconsortsizeasc, detaching);
		}
	};
}

// (272:52) 
function create_if_block_7(ctx) {
	let iconsortdatedesc;
	let current;
	iconsortdatedesc = new IconSortDateDesc({ props: { size: 24 } });

	return {
		c() {
			create_component(iconsortdatedesc.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconsortdatedesc, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconsortdatedesc.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconsortdatedesc.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconsortdatedesc, detaching);
		}
	};
}

// (270:53) 
function create_if_block_6(ctx) {
	let iconsortdateasc;
	let current;
	iconsortdateasc = new IconSortDateAsc({ props: { size: 24 } });

	return {
		c() {
			create_component(iconsortdateasc.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconsortdateasc, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconsortdateasc.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconsortdateasc.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconsortdateasc, detaching);
		}
	};
}

// (268:48) 
function create_if_block_5(ctx) {
	let iconsortalphdesc;
	let current;
	iconsortalphdesc = new IconSortAlphDesc({ props: { size: 24 } });

	return {
		c() {
			create_component(iconsortalphdesc.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconsortalphdesc, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconsortalphdesc.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconsortalphdesc.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconsortalphdesc, detaching);
		}
	};
}

// (266:16) {#if sorter == SORTERS.ABC}
function create_if_block_4(ctx) {
	let iconsortalphasc;
	let current;
	iconsortalphasc = new IconSortAlphAsc({ props: { size: 24 } });

	return {
		c() {
			create_component(iconsortalphasc.$$.fragment);
		},
		m(target, anchor) {
			mount_component(iconsortalphasc, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(iconsortalphasc.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconsortalphasc.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(iconsortalphasc, detaching);
		}
	};
}

// (307:8) {#if config.hasPassword}
function create_if_block_3(ctx) {
	let div;
	let iconlogout;
	let current;
	let mounted;
	let dispose;
	iconlogout = new IconLogout({ props: { size: 24 } });

	return {
		c() {
			div = element("div");
			create_component(iconlogout.$$.fragment);
			attr(div, "class", "navbar-link");
			attr(div, "title", "Log out");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(iconlogout, div, null);
			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*logout*/ ctx[21]);
				mounted = true;
			}
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(iconlogout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(iconlogout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(iconlogout);
			mounted = false;
			dispose();
		}
	};
}

// (316:0) {:else}
function create_else_block$1(ctx) {
	let list;
	let updating_sorter;
	let current;

	function list_sorter_binding(value) {
		/*list_sorter_binding*/ ctx[25](value);
	}

	let list_props = { itemList: /*mule*/ ctx[3].items };

	if (/*sorter*/ ctx[1] !== void 0) {
		list_props.sorter = /*sorter*/ ctx[1];
	}

	list = new List({ props: list_props });
	binding_callbacks.push(() => bind(list, 'sorter', list_sorter_binding));
	list.$on("openItem", /*click*/ ctx[8]);
	list.$on("reload", /*reload_handler_1*/ ctx[26]);
	list.$on("openPropsModal", /*doOpenPropsModal*/ ctx[17]);

	return {
		c() {
			create_component(list.$$.fragment);
		},
		m(target, anchor) {
			mount_component(list, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const list_changes = {};
			if (dirty & /*mule*/ 8) list_changes.itemList = /*mule*/ ctx[3].items;

			if (!updating_sorter && dirty & /*sorter*/ 2) {
				updating_sorter = true;
				list_changes.sorter = /*sorter*/ ctx[1];
				add_flush_callback(() => updating_sorter = false);
			}

			list.$set(list_changes);
		},
		i(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(list, detaching);
		}
	};
}

// (314:0) {#if mode == 'GRID'}
function create_if_block_2(ctx) {
	let grid;
	let current;

	grid = new Grid({
			props: { itemList: /*mule*/ ctx[3].items }
		});

	grid.$on("openItem", /*click*/ ctx[8]);
	grid.$on("reload", /*reload_handler*/ ctx[24]);
	grid.$on("openPropsModal", /*doOpenPropsModal*/ ctx[17]);

	return {
		c() {
			create_component(grid.$$.fragment);
		},
		m(target, anchor) {
			mount_component(grid, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const grid_changes = {};
			if (dirty & /*mule*/ 8) grid_changes.itemList = /*mule*/ ctx[3].items;
			grid.$set(grid_changes);
		},
		i(local) {
			if (current) return;
			transition_in(grid.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(grid.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(grid, detaching);
		}
	};
}

// (322:0) {#if propForFile != null}
function create_if_block_1$1(ctx) {
	let properties;
	let updating_item;
	let current;

	function properties_item_binding(value) {
		/*properties_item_binding*/ ctx[27](value);
	}

	let properties_props = { readOnly: /*config*/ ctx[4].readOnly };

	if (/*propForFile*/ ctx[6] !== void 0) {
		properties_props.item = /*propForFile*/ ctx[6];
	}

	properties = new Properties({ props: properties_props });
	binding_callbacks.push(() => bind(properties, 'item', properties_item_binding));
	properties.$on("toPaste", /*markToPaste*/ ctx[9]);
	properties.$on("closePropsModal", /*doClosePropsModal*/ ctx[18]);

	return {
		c() {
			create_component(properties.$$.fragment);
		},
		m(target, anchor) {
			mount_component(properties, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const properties_changes = {};
			if (dirty & /*config*/ 16) properties_changes.readOnly = /*config*/ ctx[4].readOnly;

			if (!updating_item && dirty & /*propForFile*/ 64) {
				updating_item = true;
				properties_changes.item = /*propForFile*/ ctx[6];
				add_flush_callback(() => updating_item = false);
			}

			properties.$set(properties_changes);
		},
		i(local) {
			if (current) return;
			transition_in(properties.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(properties.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(properties, detaching);
		}
	};
}

// (326:0) {#if sharingOpen}
function create_if_block$1(ctx) {
	let sharing;
	let current;

	sharing = new Sharing({
			props: {
				dir: /*path*/ ctx[0].join("") + "/",
				config: /*config*/ ctx[4]
			}
		});

	sharing.$on("closeShareModal", /*doCloseSharingModal*/ ctx[20]);

	return {
		c() {
			create_component(sharing.$$.fragment);
		},
		m(target, anchor) {
			mount_component(sharing, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const sharing_changes = {};
			if (dirty & /*path*/ 1) sharing_changes.dir = /*path*/ ctx[0].join("") + "/";
			if (dirty & /*config*/ 16) sharing_changes.config = /*config*/ ctx[4];
			sharing.$set(sharing_changes);
		},
		i(local) {
			if (current) return;
			transition_in(sharing.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(sharing.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(sharing, detaching);
		}
	};
}

function create_fragment$1(ctx) {
	let nav;
	let breadcrumb;
	let updating_path;
	let t0;
	let div12;
	let t1;
	let div0;
	let t3;
	let t4;
	let t5;
	let div1;
	let iconreload;
	let t6;
	let div2;
	let current_block_type_index;
	let if_block3;
	let t7;
	let div11;
	let div3;
	let current_block_type_index_1;
	let if_block4;
	let t8;
	let div10;
	let div4;
	let iconsortalphasc;
	let t9;
	let div5;
	let iconsortalphdesc;
	let t10;
	let div6;
	let iconsortdateasc;
	let t11;
	let div7;
	let iconsortdatedesc;
	let t12;
	let div8;
	let iconsortsizeasc;
	let t13;
	let div9;
	let iconsortsizedesc;
	let t14;
	let t15;
	let current_block_type_index_2;
	let if_block6;
	let t16;
	let div13;
	let t18;
	let div14;
	let t20;
	let div15;
	let t22;
	let t23;
	let if_block8_anchor;
	let current;
	let mounted;
	let dispose;

	function breadcrumb_path_binding(value) {
		/*breadcrumb_path_binding*/ ctx[22](value);
	}

	let breadcrumb_props = {};

	if (/*path*/ ctx[0] !== void 0) {
		breadcrumb_props.path = /*path*/ ctx[0];
	}

	breadcrumb = new Breadcrumb({ props: breadcrumb_props });
	binding_callbacks.push(() => bind(breadcrumb, 'path', breadcrumb_path_binding));
	breadcrumb.$on("pathEvent", /*pathEvent_handler*/ ctx[23]);
	let if_block0 = !!/*toPaste*/ ctx[7] && create_if_block_13(ctx);
	let if_block1 = !/*config*/ ctx[4].readOnly && create_if_block_12(ctx);
	let if_block2 = /*config*/ ctx[4].sharing != null && create_if_block_11(ctx);
	iconreload = new IconReload({ props: { size: 24 } });
	const if_block_creators = [create_if_block_10, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*mode*/ ctx[2] == 'GRID') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const if_block_creators_1 = [
		create_if_block_4,
		create_if_block_5,
		create_if_block_6,
		create_if_block_7,
		create_if_block_8,
		create_if_block_9
	];

	const if_blocks_1 = [];

	function select_block_type_1(ctx, dirty) {
		if (/*sorter*/ ctx[1] == SORTERS.ABC) return 0;
		if (/*sorter*/ ctx[1] == SORTERS.CBA) return 1;
		if (/*sorter*/ ctx[1] == SORTERS.OldFirst) return 2;
		if (/*sorter*/ ctx[1] == SORTERS.OldLast) return 3;
		if (/*sorter*/ ctx[1] == SORTERS.SmallFirst) return 4;
		if (/*sorter*/ ctx[1] == SORTERS.SmallLast) return 5;
		return -1;
	}

	if (~(current_block_type_index_1 = select_block_type_1(ctx))) {
		if_block4 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
	}

	iconsortalphasc = new IconSortAlphAsc({ props: { size: 24 } });
	iconsortalphdesc = new IconSortAlphDesc({ props: { size: 24 } });
	iconsortdateasc = new IconSortDateAsc({ props: { size: 24 } });
	iconsortdatedesc = new IconSortDateDesc({ props: { size: 24 } });
	iconsortsizeasc = new IconSortSizeAsc({ props: { size: 24 } });
	iconsortsizedesc = new IconSortSizeDesc({ props: { size: 24 } });
	let if_block5 = /*config*/ ctx[4].hasPassword && create_if_block_3(ctx);
	const if_block_creators_2 = [create_if_block_2, create_else_block$1];
	const if_blocks_2 = [];

	function select_block_type_2(ctx, dirty) {
		if (/*mode*/ ctx[2] == 'GRID') return 0;
		return 1;
	}

	current_block_type_index_2 = select_block_type_2(ctx);
	if_block6 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
	let if_block7 = /*propForFile*/ ctx[6] != null && create_if_block_1$1(ctx);
	let if_block8 = /*sharingOpen*/ ctx[5] && create_if_block$1(ctx);

	return {
		c() {
			nav = element("nav");
			create_component(breadcrumb.$$.fragment);
			t0 = space();
			div12 = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			div0 = element("div");
			div0.textContent = " ";
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			if (if_block2) if_block2.c();
			t5 = space();
			div1 = element("div");
			create_component(iconreload.$$.fragment);
			t6 = space();
			div2 = element("div");
			if_block3.c();
			t7 = space();
			div11 = element("div");
			div3 = element("div");
			if (if_block4) if_block4.c();
			t8 = space();
			div10 = element("div");
			div4 = element("div");
			create_component(iconsortalphasc.$$.fragment);
			t9 = space();
			div5 = element("div");
			create_component(iconsortalphdesc.$$.fragment);
			t10 = space();
			div6 = element("div");
			create_component(iconsortdateasc.$$.fragment);
			t11 = space();
			div7 = element("div");
			create_component(iconsortdatedesc.$$.fragment);
			t12 = space();
			div8 = element("div");
			create_component(iconsortsizeasc.$$.fragment);
			t13 = space();
			div9 = element("div");
			create_component(iconsortsizedesc.$$.fragment);
			t14 = space();
			if (if_block5) if_block5.c();
			t15 = space();
			if_block6.c();
			t16 = space();
			div13 = element("div");
			div13.textContent = " ";
			t18 = space();
			div14 = element("div");
			div14.textContent = " ";
			t20 = space();
			div15 = element("div");
			div15.textContent = " ";
			t22 = space();
			if (if_block7) if_block7.c();
			t23 = space();
			if (if_block8) if_block8.c();
			if_block8_anchor = empty();
			attr(div1, "class", "navbar-link");
			attr(div1, "title", "Reload file list");
			attr(div2, "class", "navbar-link");
			attr(div2, "title", "View mode");
			attr(div3, "class", "navbar-link");
			attr(div3, "data-target", "SortBy");
			attr(div3, "title", "Sort by");
			set_style(div3, "height", "40px");
			attr(div4, "class", "dropdown-item");
			attr(div4, "title", "Sort alphabetically, ascending");
			toggle_class(div4, "active", /*sorter*/ ctx[1] == SORTERS.ABC);
			attr(div5, "class", "dropdown-item");
			attr(div5, "title", "Sort alphabetically, descending");
			toggle_class(div5, "active", /*sorter*/ ctx[1] == SORTERS.CBA);
			attr(div6, "class", "dropdown-item");
			attr(div6, "title", "Sort by date, ascending");
			toggle_class(div6, "active", /*sorter*/ ctx[1] == SORTERS.OldFirst);
			attr(div7, "class", "dropdown-item");
			attr(div7, "title", "Sort by date, descending");
			toggle_class(div7, "active", /*sorter*/ ctx[1] == SORTERS.OldLast);
			attr(div8, "class", "dropdown-item");
			attr(div8, "title", "Sort by size, ascending");
			toggle_class(div8, "active", /*sorter*/ ctx[1] == SORTERS.SmallFirst);
			attr(div9, "class", "dropdown-item");
			attr(div9, "title", "Sort by size, descending");
			toggle_class(div9, "active", /*sorter*/ ctx[1] == SORTERS.SmallLast);
			attr(div10, "class", "dropdown-content dropdown-right white shadow-1");
			attr(div11, "class", "dropdown");
			attr(div11, "id", "SortBy");
			attr(div12, "class", "navbar-menu ml-auto");
			set_style(div12, "height", "40px");
			attr(nav, "class", "navbar");
			set_style(nav, "height", "40px");
		},
		m(target, anchor) {
			insert(target, nav, anchor);
			mount_component(breadcrumb, nav, null);
			append(nav, t0);
			append(nav, div12);
			if (if_block0) if_block0.m(div12, null);
			append(div12, t1);
			append(div12, div0);
			append(div12, t3);
			if (if_block1) if_block1.m(div12, null);
			append(div12, t4);
			if (if_block2) if_block2.m(div12, null);
			append(div12, t5);
			append(div12, div1);
			mount_component(iconreload, div1, null);
			append(div12, t6);
			append(div12, div2);
			if_blocks[current_block_type_index].m(div2, null);
			append(div12, t7);
			append(div12, div11);
			append(div11, div3);

			if (~current_block_type_index_1) {
				if_blocks_1[current_block_type_index_1].m(div3, null);
			}

			append(div11, t8);
			append(div11, div10);
			append(div10, div4);
			mount_component(iconsortalphasc, div4, null);
			append(div10, t9);
			append(div10, div5);
			mount_component(iconsortalphdesc, div5, null);
			append(div10, t10);
			append(div10, div6);
			mount_component(iconsortdateasc, div6, null);
			append(div10, t11);
			append(div10, div7);
			mount_component(iconsortdatedesc, div7, null);
			append(div10, t12);
			append(div10, div8);
			mount_component(iconsortsizeasc, div8, null);
			append(div10, t13);
			append(div10, div9);
			mount_component(iconsortsizedesc, div9, null);
			append(div12, t14);
			if (if_block5) if_block5.m(div12, null);
			insert(target, t15, anchor);
			if_blocks_2[current_block_type_index_2].m(target, anchor);
			insert(target, t16, anchor);
			insert(target, div13, anchor);
			insert(target, t18, anchor);
			insert(target, div14, anchor);
			insert(target, t20, anchor);
			insert(target, div15, anchor);
			insert(target, t22, anchor);
			if (if_block7) if_block7.m(target, anchor);
			insert(target, t23, anchor);
			if (if_block8) if_block8.m(target, anchor);
			insert(target, if_block8_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div1, "click", /*reload*/ ctx[16]),
					listen(div2, "click", /*gridOrList*/ ctx[13]),
					listen(div4, "click", /*resort*/ ctx[12](SORTERS.ABC)),
					listen(div5, "click", /*resort*/ ctx[12](SORTERS.CBA)),
					listen(div6, "click", /*resort*/ ctx[12](SORTERS.OldFirst)),
					listen(div7, "click", /*resort*/ ctx[12](SORTERS.OldLast)),
					listen(div8, "click", /*resort*/ ctx[12](SORTERS.SmallFirst)),
					listen(div9, "click", /*resort*/ ctx[12](SORTERS.SmallLast))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const breadcrumb_changes = {};

			if (!updating_path && dirty & /*path*/ 1) {
				updating_path = true;
				breadcrumb_changes.path = /*path*/ ctx[0];
				add_flush_callback(() => updating_path = false);
			}

			breadcrumb.$set(breadcrumb_changes);

			if (!!/*toPaste*/ ctx[7]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*toPaste*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_13(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div12, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!/*config*/ ctx[4].readOnly) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*config*/ 16) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_12(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div12, t4);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*config*/ ctx[4].sharing != null) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*config*/ 16) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_11(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div12, t5);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block3 = if_blocks[current_block_type_index];

				if (!if_block3) {
					if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block3.c();
				}

				transition_in(if_block3, 1);
				if_block3.m(div2, null);
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);

			if (current_block_type_index_1 !== previous_block_index_1) {
				if (if_block4) {
					group_outros();

					transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
						if_blocks_1[previous_block_index_1] = null;
					});

					check_outros();
				}

				if (~current_block_type_index_1) {
					if_block4 = if_blocks_1[current_block_type_index_1];

					if (!if_block4) {
						if_block4 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
						if_block4.c();
					}

					transition_in(if_block4, 1);
					if_block4.m(div3, null);
				} else {
					if_block4 = null;
				}
			}

			if (!current || dirty & /*sorter, SORTERS*/ 2) {
				toggle_class(div4, "active", /*sorter*/ ctx[1] == SORTERS.ABC);
			}

			if (!current || dirty & /*sorter, SORTERS*/ 2) {
				toggle_class(div5, "active", /*sorter*/ ctx[1] == SORTERS.CBA);
			}

			if (!current || dirty & /*sorter, SORTERS*/ 2) {
				toggle_class(div6, "active", /*sorter*/ ctx[1] == SORTERS.OldFirst);
			}

			if (!current || dirty & /*sorter, SORTERS*/ 2) {
				toggle_class(div7, "active", /*sorter*/ ctx[1] == SORTERS.OldLast);
			}

			if (!current || dirty & /*sorter, SORTERS*/ 2) {
				toggle_class(div8, "active", /*sorter*/ ctx[1] == SORTERS.SmallFirst);
			}

			if (!current || dirty & /*sorter, SORTERS*/ 2) {
				toggle_class(div9, "active", /*sorter*/ ctx[1] == SORTERS.SmallLast);
			}

			if (/*config*/ ctx[4].hasPassword) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty & /*config*/ 16) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_3(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(div12, null);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			let previous_block_index_2 = current_block_type_index_2;
			current_block_type_index_2 = select_block_type_2(ctx);

			if (current_block_type_index_2 === previous_block_index_2) {
				if_blocks_2[current_block_type_index_2].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
					if_blocks_2[previous_block_index_2] = null;
				});

				check_outros();
				if_block6 = if_blocks_2[current_block_type_index_2];

				if (!if_block6) {
					if_block6 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
					if_block6.c();
				} else {
					if_block6.p(ctx, dirty);
				}

				transition_in(if_block6, 1);
				if_block6.m(t16.parentNode, t16);
			}

			if (/*propForFile*/ ctx[6] != null) {
				if (if_block7) {
					if_block7.p(ctx, dirty);

					if (dirty & /*propForFile*/ 64) {
						transition_in(if_block7, 1);
					}
				} else {
					if_block7 = create_if_block_1$1(ctx);
					if_block7.c();
					transition_in(if_block7, 1);
					if_block7.m(t23.parentNode, t23);
				}
			} else if (if_block7) {
				group_outros();

				transition_out(if_block7, 1, 1, () => {
					if_block7 = null;
				});

				check_outros();
			}

			if (/*sharingOpen*/ ctx[5]) {
				if (if_block8) {
					if_block8.p(ctx, dirty);

					if (dirty & /*sharingOpen*/ 32) {
						transition_in(if_block8, 1);
					}
				} else {
					if_block8 = create_if_block$1(ctx);
					if_block8.c();
					transition_in(if_block8, 1);
					if_block8.m(if_block8_anchor.parentNode, if_block8_anchor);
				}
			} else if (if_block8) {
				group_outros();

				transition_out(if_block8, 1, 1, () => {
					if_block8 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(breadcrumb.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(iconreload.$$.fragment, local);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(iconsortalphasc.$$.fragment, local);
			transition_in(iconsortalphdesc.$$.fragment, local);
			transition_in(iconsortdateasc.$$.fragment, local);
			transition_in(iconsortdatedesc.$$.fragment, local);
			transition_in(iconsortsizeasc.$$.fragment, local);
			transition_in(iconsortsizedesc.$$.fragment, local);
			transition_in(if_block5);
			transition_in(if_block6);
			transition_in(if_block7);
			transition_in(if_block8);
			current = true;
		},
		o(local) {
			transition_out(breadcrumb.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(iconreload.$$.fragment, local);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(iconsortalphasc.$$.fragment, local);
			transition_out(iconsortalphdesc.$$.fragment, local);
			transition_out(iconsortdateasc.$$.fragment, local);
			transition_out(iconsortdatedesc.$$.fragment, local);
			transition_out(iconsortsizeasc.$$.fragment, local);
			transition_out(iconsortsizedesc.$$.fragment, local);
			transition_out(if_block5);
			transition_out(if_block6);
			transition_out(if_block7);
			transition_out(if_block8);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(nav);
			destroy_component(breadcrumb);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			destroy_component(iconreload);
			if_blocks[current_block_type_index].d();

			if (~current_block_type_index_1) {
				if_blocks_1[current_block_type_index_1].d();
			}

			destroy_component(iconsortalphasc);
			destroy_component(iconsortalphdesc);
			destroy_component(iconsortdateasc);
			destroy_component(iconsortdatedesc);
			destroy_component(iconsortsizeasc);
			destroy_component(iconsortsizedesc);
			if (if_block5) if_block5.d();
			if (detaching) detach(t15);
			if_blocks_2[current_block_type_index_2].d(detaching);
			if (detaching) detach(t16);
			if (detaching) detach(div13);
			if (detaching) detach(t18);
			if (detaching) detach(div14);
			if (detaching) detach(t20);
			if (detaching) detach(div15);
			if (detaching) detach(t22);
			if (if_block7) if_block7.d(detaching);
			if (detaching) detach(t23);
			if (if_block8) if_block8.d(detaching);
			if (detaching) detach(if_block8_anchor);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let toPaste;
	let isCut;
	let propForFile;
	let sharingOpen;
	let { path } = $$props;
	let { mule } = $$props;
	let { sorter } = $$props;
	let { mode } = $$props;
	let { config } = $$props;
	const dispatch = createEventDispatcher();

	onMount(() => {
		resort(SORTERS.ABC)();
		new Wo("#SortBy");
	});

	onDestroy(() => {
		ma("#SortBy");
	});

	function click(event) {
		const file = mule.items.find(i => i.uuid == event.detail.uuid);

		if (file.isDir) {
			// cd
			let nuPath = path;

			if (file.name == "../") nuPath = nuPath.slice(0, nuPath.length - 1); else nuPath = [...nuPath, file.name];
			dispatch("pathEvent", { path: nuPath });
		} else {
			dispatch("openItem", event.detail);
		}
	}

	function markToPaste(event) {
		$$invalidate(7, toPaste = event.detail.file);
		isCut = event.detail.isCut;
	}

	function unmarkToPaste() {
		$$invalidate(7, toPaste = null);
		isCut = false;
	}

	async function doPaste() {
		const srv = isCut ? "move" : "copy";
		const dest = path.join("") + "/";

		const res = await fetch("fsOps/" + srv + "?path=" + encodeURIComponent(toPaste.path) + "&destDir=" + encodeURIComponent(dest), {
			method: "POST",
			headers: { "X-Csrf-Token": getCookie("csrf_") }
		});

		if (res.status != 200) {
			await Swal.fire({
				icon: "error",
				text: await res.text(),
				confirmButtonColor: "#0a6bb8"
			});
		} else {
			await Swal.fire({
				icon: "success",
				titleText: "Done!",
				confirmButtonColor: "#0a6bb8"
			});

			unmarkToPaste();
			reload();
		}
	}

	function resort(_sorter) {
		return function () {
			$$invalidate(1, sorter = _sorter);
		};
	}

	function gridOrList() {
		$$invalidate(2, mode = mode == "GRID" ? "LIST" : "GRID");
	}

	async function newFolder() {
		const { value: name } = await Swal.fire({
			titleText: "Enter folder name",
			confirmButtonColor: "#0a6bb8",
			showCancelButton: true,
			input: "text",
			inputAttributes: {
				autocapitalize: "off",
				autocorrect: "off"
			}
		});

		if (!name) {
			return;
		}

		const res = await fetch("fsOps/newFolder?path=" + encodeURIComponent(path.join("") + "/" + name), {
			method: "PUT",
			headers: { "X-Csrf-Token": getCookie("csrf_") }
		});

		if (res.status != 200) {
			await Swal.fire({
				icon: "error",
				text: await res.text(),
				confirmButtonColor: "#0a6bb8"
			});
		} else {
			await Swal.fire({
				icon: "success",
				titleText: "Done!",
				confirmButtonColor: "#0a6bb8"
			});

			reload();
		}
	}

	async function doUpload() {
		const { value: file } = await Swal.fire({
			titleText: "Select files",
			confirmButtonColor: "#0a6bb8",
			showCancelButton: true,
			input: "file"
		});

		if (!file) return;

		if (file.size > config.maxReqSize) {
			await Swal.fire({
				icon: "error",
				html: "File too large; try launching the server<br/>" + "with a larger <code>--max-upload-size</code>.",
				confirmButtonColor: "#0a6bb8"
			});

			return;
		}

		const fd = new FormData();
		fd.append("doc", file);

		try {
			const res = await fetch("fsOps/upload?path=" + encodeURIComponent(path.join("") + "/"), {
				method: "PUT",
				body: fd,
				headers: { "X-Csrf-Token": getCookie("csrf_") }
			});

			if (res.status != 200) {
				await Swal.fire({
					icon: "error",
					text: await res.text(),
					confirmButtonColor: "#0a6bb8"
				});
			} else {
				await Swal.fire({
					icon: "success",
					titleText: "Done!",
					confirmButtonColor: "#0a6bb8"
				});

				reload();
			}
		} catch(e) {
			// in Firefox, some network errors (e.g. request too large)
			// are rendered as TypeError's, without further details. NOT NICE
			await Swal.fire({
				icon: "error",
				text: e.message,
				confirmButtonColor: "#0a6bb8"
			});

			return;
		}
	}

	function reload() {
		dispatch("reload", {});
	}

	function doOpenPropsModal(event) {
		$$invalidate(6, propForFile = event.detail.file);
	}

	function doClosePropsModal(event) {
		$$invalidate(6, propForFile = null);
		reload();
	}

	function doOpenSharingModal(event) {
		$$invalidate(5, sharingOpen = true);
	}

	function doCloseSharingModal(event) {
		$$invalidate(5, sharingOpen = false);
	}

	function logout() {
		dispatch("logout", {});
	}

	function breadcrumb_path_binding(value) {
		path = value;
		$$invalidate(0, path);
	}

	function pathEvent_handler(event) {
		bubble.call(this, $$self, event);
	}

	function reload_handler(event) {
		bubble.call(this, $$self, event);
	}

	function list_sorter_binding(value) {
		sorter = value;
		$$invalidate(1, sorter);
	}

	function reload_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function properties_item_binding(value) {
		propForFile = value;
		$$invalidate(6, propForFile);
	}

	$$self.$$set = $$props => {
		if ('path' in $$props) $$invalidate(0, path = $$props.path);
		if ('mule' in $$props) $$invalidate(3, mule = $$props.mule);
		if ('sorter' in $$props) $$invalidate(1, sorter = $$props.sorter);
		if ('mode' in $$props) $$invalidate(2, mode = $$props.mode);
		if ('config' in $$props) $$invalidate(4, config = $$props.config);
	};

	$$invalidate(7, toPaste = null);
	isCut = false;
	$$invalidate(6, propForFile = null);
	$$invalidate(5, sharingOpen = false);

	return [
		path,
		sorter,
		mode,
		mule,
		config,
		sharingOpen,
		propForFile,
		toPaste,
		click,
		markToPaste,
		unmarkToPaste,
		doPaste,
		resort,
		gridOrList,
		newFolder,
		doUpload,
		reload,
		doOpenPropsModal,
		doClosePropsModal,
		doOpenSharingModal,
		doCloseSharingModal,
		logout,
		breadcrumb_path_binding,
		pathEvent_handler,
		reload_handler,
		list_sorter_binding,
		reload_handler_1,
		properties_item_binding
	];
}

class FileManager extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			path: 0,
			mule: 3,
			sorter: 1,
			mode: 2,
			config: 4
		});
	}
}

const axentix = '';

const global = '';

const FileManager_svelte_svelte_type_style_lang = '';

/* src/svelte/components/apps/FileManager/FileManager.svelte generated by Svelte v3.53.1 */

function create_else_block(ctx) {
	let preview;
	let current;

	preview = new Preview({
			props: {
				files: /*mule*/ ctx[1].files,
				fileIdx: /*slideshowIndex*/ ctx[4]
			}
		});

	preview.$on("closePreview", /*closeSlideshow*/ ctx[10]);

	return {
		c() {
			create_component(preview.$$.fragment);
		},
		m(target, anchor) {
			mount_component(preview, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const preview_changes = {};
			if (dirty & /*mule*/ 2) preview_changes.files = /*mule*/ ctx[1].files;
			if (dirty & /*slideshowIndex*/ 16) preview_changes.fileIdx = /*slideshowIndex*/ ctx[4];
			preview.$set(preview_changes);
		},
		i(local) {
			if (current) return;
			transition_in(preview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(preview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(preview, detaching);
		}
	};
}

// (154:4) {#if slideshowIndex < 0}
function create_if_block(ctx) {
	let filemanager;
	let updating_path;
	let updating_mule;
	let updating_sorter;
	let updating_mode;
	let t;
	let if_block_anchor;
	let current;

	function filemanager_path_binding(value) {
		/*filemanager_path_binding*/ ctx[12](value);
	}

	function filemanager_mule_binding(value) {
		/*filemanager_mule_binding*/ ctx[13](value);
	}

	function filemanager_sorter_binding(value) {
		/*filemanager_sorter_binding*/ ctx[14](value);
	}

	function filemanager_mode_binding(value) {
		/*filemanager_mode_binding*/ ctx[15](value);
	}

	let filemanager_props = { config: /*config*/ ctx[0] };

	if (/*path*/ ctx[3] !== void 0) {
		filemanager_props.path = /*path*/ ctx[3];
	}

	if (/*mule*/ ctx[1] !== void 0) {
		filemanager_props.mule = /*mule*/ ctx[1];
	}

	if (/*sorter*/ ctx[2] !== void 0) {
		filemanager_props.sorter = /*sorter*/ ctx[2];
	}

	if (/*mode*/ ctx[6] !== void 0) {
		filemanager_props.mode = /*mode*/ ctx[6];
	}

	filemanager = new FileManager({ props: filemanager_props });
	binding_callbacks.push(() => bind(filemanager, 'path', filemanager_path_binding));
	binding_callbacks.push(() => bind(filemanager, 'mule', filemanager_mule_binding));
	binding_callbacks.push(() => bind(filemanager, 'sorter', filemanager_sorter_binding));
	binding_callbacks.push(() => bind(filemanager, 'mode', filemanager_mode_binding));
	filemanager.$on("pathEvent", /*chPath*/ ctx[9]);
	filemanager.$on("openItem", /*openSlideshow*/ ctx[8]);
	filemanager.$on("reload", /*reload*/ ctx[11]);
	filemanager.$on("logout", /*logout_handler*/ ctx[16]);
	let if_block = !!/*footer*/ ctx[5] && create_if_block_1(ctx);

	return {
		c() {
			create_component(filemanager.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(filemanager, target, anchor);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const filemanager_changes = {};
			if (dirty & /*config*/ 1) filemanager_changes.config = /*config*/ ctx[0];

			if (!updating_path && dirty & /*path*/ 8) {
				updating_path = true;
				filemanager_changes.path = /*path*/ ctx[3];
				add_flush_callback(() => updating_path = false);
			}

			if (!updating_mule && dirty & /*mule*/ 2) {
				updating_mule = true;
				filemanager_changes.mule = /*mule*/ ctx[1];
				add_flush_callback(() => updating_mule = false);
			}

			if (!updating_sorter && dirty & /*sorter*/ 4) {
				updating_sorter = true;
				filemanager_changes.sorter = /*sorter*/ ctx[2];
				add_flush_callback(() => updating_sorter = false);
			}

			if (!updating_mode && dirty & /*mode*/ 64) {
				updating_mode = true;
				filemanager_changes.mode = /*mode*/ ctx[6];
				add_flush_callback(() => updating_mode = false);
			}

			filemanager.$set(filemanager_changes);

			if (!!/*footer*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*footer*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(filemanager.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(filemanager.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(filemanager, detaching);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (163:8) {#if !!footer}
function create_if_block_1(ctx) {
	let footer_1;
	let raw_value = /*footer*/ ctx[5].html + "";
	let footer_1_class_value;
	let footer_1_outro;
	let current;

	return {
		c() {
			footer_1 = element("footer");
			attr(footer_1, "class", footer_1_class_value = "footer font-s1 lh-1 " + /*footer*/ ctx[5].color + " svelte-10bss5q");
		},
		m(target, anchor) {
			insert(target, footer_1, anchor);
			footer_1.innerHTML = raw_value;
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*footer*/ 32) && raw_value !== (raw_value = /*footer*/ ctx[5].html + "")) footer_1.innerHTML = raw_value;
			if (!current || dirty & /*footer*/ 32 && footer_1_class_value !== (footer_1_class_value = "footer font-s1 lh-1 " + /*footer*/ ctx[5].color + " svelte-10bss5q")) {
				attr(footer_1, "class", footer_1_class_value);
			}
		},
		i(local) {
			if (current) return;
			if (footer_1_outro) footer_1_outro.end(1);
			current = true;
		},
		o(local) {
			footer_1_outro = create_out_transition(footer_1, fade, {});
			current = false;
		},
		d(detaching) {
			if (detaching) detach(footer_1);
			if (detaching && footer_1_outro) footer_1_outro.end();
		}
	};
}

function create_fragment(ctx) {
	let section1;
	let header;
	let t;
	let section0;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*slideshowIndex*/ ctx[4] < 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			section1 = element("section");
			header = element("header");
			t = space();
			section0 = element("section");
			if_block.c();
			attr(header, "class", "app-window-drag-handle titlebar svelte-10bss5q");
			attr(section0, "class", "main-area svelte-10bss5q");
			attr(section1, "class", "container svelte-10bss5q");
			toggle_class(section1, "dark", /*$theme*/ ctx[7].scheme === 'dark');
		},
		m(target, anchor) {
			insert(target, section1, anchor);
			append(section1, header);
			append(section1, t);
			append(section1, section0);
			if_blocks[current_block_type_index].m(section0, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(section0, null);
			}

			if (!current || dirty & /*$theme*/ 128) {
				toggle_class(section1, "dark", /*$theme*/ ctx[7].scheme === 'dark');
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(section1);
			if_blocks[current_block_type_index].d();
		}
	};
}

function hash2path() {
	return decodeURIComponent(window.location.hash.substring(1)).replace(/^\/+/, '').replace(/\/+$/, '').split("/").filter(el => el != "" && el != null); // removes trailing and leading '/'
	// splits over '/'
}

function instance($$self, $$props, $$invalidate) {
	let mule;
	let path;
	let slideshowIndex;
	let sorter;
	let mode;
	let footer;
	let $theme;
	component_subscribe($$self, theme, $$value => $$invalidate(7, $theme = $$value));
	const fs = globalThis.fs;

	let { config = {
		title: "",
		version: "0",
		maxReqSize: 100,
		readOnly: false,
		sharing: null,
		hasPassword: false
	} } = $$props;

	let hashPathWasSetByMe = true;
	let footers = [];
	let footerHandler = -1;

	function addFooter(obj) {
		function nxtFooter() {
			$$invalidate(5, footer = footers.shift());

			if (!footer) {
				footerHandler = -1;
			} else {
				footerHandler = setTimeout(nxtFooter, 2000);
			}
		}

		if (footerHandler < 0) {
			$$invalidate(5, footer = obj);
			footerHandler = setTimeout(nxtFooter, 2000);
		} else {
			footers.push(obj);
		}
	}

	onMount(() => {
		addFooter({
			color: "blue dark-2",
			html: `<span>
          🐶 <a class="pup-a" target="_blank" href="https://github.com/proofrock/pupcloud/">Pupcloud</a>
                ${config.version} -
            <a class="pup-a" href="https://germ.gitbook.io/pupcloud/">Documentation</a> -
            <a class="pup-a" href="https://github.com/proofrock/pupcloud">Github Page</a> -
            <a class="pup-a" href="https://pupcloud.vercel.app/">Demo site</a>
        </span>`
		});

		if (config.readOnly) {
			addFooter({
				color: "yellow",
				html: "<span>🐶 Pupcloud is in <b>read only</b> mode.</span>"
			});
		}

		//loadPath(hash2path());
		loadPath(path);
	});

	async function loadPath(nuPath) {
		const nuPathStr = "/" + nuPath.join("/");

		//console.log("loadPath nuPath", nuPath)
		console.log("loadPath", nuPathStr, new Error().stack);

		const itemsList = await fs.promises.readdir(nuPathStr);

		const items = await Promise.all(itemsList.map(async fileName => {
			const filePath = nuPathStr + (nuPathStr == "/" ? "" : "/") + fileName;
			const stats = await fs.promises.stat(filePath);

			// TODO filemanager should use the node fs api
			const fileobj = {
				stats,
				isLink: stats.isSymbolicLink(),
				mimeType: stats.isDirectory() ? "#directory" : "text/plain",
				name: fileName,
				size: stats.size,
				chDate: +stats.mtime / 1000,
				owner: 0,
				group: 0,
				permissions: stats.mode
			};

			return fileobj;
		}));

		//console.log("loadPath items", items);
		$$invalidate(1, mule = new Mule(items, nuPath).sort(sorter));

		$$invalidate(3, path = nuPath);
	}

	window.addEventListener(
		'hashchange',
		() => {
			if (hashPathWasSetByMe) hashPathWasSetByMe = false; else loadPath(hash2path());
		},
		false
	);

	function openSlideshow(event) {
		$$invalidate(4, slideshowIndex = mule.files.findIndex(i => i.uuid == event.detail.uuid));
	}

	function chPath(event) {
		loadPath(event.detail.path);
	}

	function closeSlideshow() {
		$$invalidate(4, slideshowIndex = -1);
	}

	function reload() {
		loadPath(path);
	}

	function filemanager_path_binding(value) {
		path = value;
		$$invalidate(3, path);
	}

	function filemanager_mule_binding(value) {
		mule = value;
		($$invalidate(1, mule), $$invalidate(2, sorter));
	}

	function filemanager_sorter_binding(value) {
		sorter = value;
		$$invalidate(2, sorter);
	}

	function filemanager_mode_binding(value) {
		mode = value;
		$$invalidate(6, mode);
	}

	function logout_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('config' in $$props) $$invalidate(0, config = $$props.config);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*mule, sorter*/ 6) {
			{
				$$invalidate(1, mule = mule.sort(sorter));
			}
		}
	};

	$$invalidate(1, mule = Mule.empty());

	//$: path = [];
	$$invalidate(3, path = ["home", "user"]);

	$$invalidate(4, slideshowIndex = -1);

	// FIXME sorting is broken
	$$invalidate(2, sorter = SORTERS.ABC);

	// FIXME grid is ugly in small window. blame axentix css?
	//$: mode = "GRID";
	$$invalidate(6, mode = "LIST");

	$$invalidate(5, footer = null);

	return [
		config,
		mule,
		sorter,
		path,
		slideshowIndex,
		footer,
		mode,
		$theme,
		openSlideshow,
		chPath,
		closeSlideshow,
		reload,
		filemanager_path_binding,
		filemanager_mule_binding,
		filemanager_sorter_binding,
		filemanager_mode_binding,
		logout_handler
	];
}

class FileManager_1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { config: 0 });
	}
}

export { FileManager_1 as default };
